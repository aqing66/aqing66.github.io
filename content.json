{"meta":{"title":"阿清的博客","subtitle":"白驹过隙","description":"珍惜时间！","author":"阿清","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-07-09T08:16:56.000Z","updated":"2020-07-09T13:09:16.176Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-09T08:17:06.000Z","updated":"2020-07-09T13:07:17.744Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-07-12T08:16:50.000Z","updated":"2020-07-12T08:16:50.054Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程_并发","slug":"多线程-并发","date":"2020-08-15T03:36:30.000Z","updated":"2020-08-17T03:57:42.322Z","comments":true,"path":"post/af256493.html","link":"","permalink":"http://yoursite.com/post/af256493.html","excerpt":"并发","text":"并发 并发_非同步案例1以之前的抢票代码为例，在多个线程同时操作一个资源的时候，会出现两张种情况： 抢到的票为负数 抢到同一张票 抢到票为负数的原因：张三和李四同时看见最后一张票，张三线程进入方法，由于sleep方法模拟延迟，张三看见的还是有票，当延迟时间过去后，就会多减去一个1。 抢到同一张票的原因：由于每个线程都有自己的工作空间，当张三从进程里拿到数据时候，在张三还没有返回数据的时候，李四的进程进来拿里进程的数据。就这样拿到了相同的数据 案例二取钱操作：本质上和抢票一样，一个线程进入后有延迟，资源未处理，这时候另一个线程进来，进行处理数据同时之前的线程数据处理完，后一个线程就对处理过的数据再进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Yh &#123; public static void main(String[] args) &#123; Zh z=new Zh(\"礼金\",100); Qq t1=new Qq(z,60,\"zhangsan\"); Qq t2=new Qq(z,70,\"lisi\"); t1.start(); t2.start(); &#125;&#125;class Zh&#123; String name; int mony; public Zh(String name, int mony) &#123; super(); this.name = name; this.mony = mony; &#125;&#125;class Qq extends Thread&#123; Zh zh; int drawingmoney; int countmony; public Qq(Zh zh, int drawingmoney,String name) &#123; super(name); this.zh = zh; this.drawingmoney = drawingmoney; &#125; @Override public void run() &#123; test(); &#125; void test()&#123; if(zh.mony&lt;drawingmoney) &#123; return; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; zh.mony-=drawingmoney; countmony+=drawingmoney; System.out.println(this.getName()+\"账户余额\"+zh.mony); System.out.println(this.getName()+\"口袋金额\"+countmony); &#125; &#125; synchronized synchronized 方法通过在方法声明中加入 synchronized关键字来声明，语法如下：public synchronized void accessVal(int newVal);synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。 synchronized块synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下： 1234synchronized(syncObject) &#123; //允许访问控制的代码 &#125; 解决抢票和银行取钱代码的并发 抢票在test方法加上synchronize关键字，或者对test操作的ticket对象进行synchronize代码块锁定。使用代码块需要注意锁定的是不变元素，锁定的地址是不变的元素 1234567891011121314151617181920212223242526272829303132333435public class Tickt implements Runnable&#123; private int ticket=10; boolean flag=true; @Override public void run() &#123; while(flag) &#123; test() ; &#125; &#125; void test()&#123;synchronized ( this) &#123; if (ticket&lt;0) &#123; flag=false; return; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"********\"+ticket--); &#125; &#125; public static void main(String[] args) &#123; Tickt t=new Tickt(); new Thread(t,\"zhangsan\").start(); new Thread(t,\"lisi\").start(); &#125; &#125; 银行注意锁定的不是银行对象，需呀注意修改的信息是账户信息，所以锁的是账户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Yh &#123; public static void main(String[] args) &#123; Zh z=new Zh(\"礼金\",100); Qq t1=new Qq(z,60,\"zhangsan\"); Qq t2=new Qq(z,70,\"lisi\"); t1.start(); t2.start(); &#125;&#125;class Zh&#123; String name; int mony; public Zh(String name, int mony) &#123; super(); this.name = name; this.mony = mony; &#125; &#125;class Qq extends Thread&#123; Zh zh; int drawingmoney; int countmony; public Qq(Zh zh, int drawingmoney,String name) &#123; super(name); this.zh = zh; this.drawingmoney = drawingmoney; &#125; @Override public void run() &#123; test(); &#125; void test()&#123; synchronized (zh) &#123; if(zh.mony&lt;drawingmoney) &#123; return; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; zh.mony-=drawingmoney; countmony+=drawingmoney; System.out.println(this.getName()+\"账户余额\"+zh.mony); System.out.println(this.getName()+\"口袋金额\"+countmony); &#125; &#125;&#125; 练习电影院选票思路：创建消费者和电影院类，电影院有剩余座位和订票方法。消费者有买票座和姓名变量。将电影院的座位用容器表示,订票方法传进来消费者定的座位返回值为blooean类型，输出可用的座位，创建数组copy，用copy减传进来的数组，如果座位数减去copy不等于穿进来的数，将返回false，成功则将copy的这个数组传给座位数。在消费者调用该方法，并将方法返回值给flag，如果成功则输出订购的座位，否则返回订购失败 。这个过程主要是判断购票是否有座位，所以将锁设在电影院对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Dy &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; available=new ArrayList&lt;&gt;(); available.add(1); available.add(2); available.add(3); available.add(4); available.add(5); available.add(6); List&lt;Integer&gt; s2=new ArrayList&lt;&gt;(); s2.add(2); s2.add(6); List&lt;Integer&gt; s1=new ArrayList&lt;&gt;(); s1.add(1); s1.add(3); s1.add(5); Cinma c=new Cinma(available, \"电影院\"); new Thread( new Custom(c,s1),\"张三\").start(); new Thread( new Custom(c,s2),\"李四\").start(); &#125;&#125;class Custom implements Runnable&#123; Cinma cinma; List&lt;Integer&gt; seats; public Custom(Cinma cinma, List&lt;Integer&gt; seats) &#123; super(); this.cinma = cinma; this.seats = seats; &#125; @Override public void run() &#123; synchronized (cinma) &#123; boolean flag=cinma.bookTicket(seats); if(flag) &#123; System.out.println(\"出票成功#####\"+Thread.currentThread().getName()+\"######位置为\"+seats); &#125;else System.out.println(\"出票失败\"+Thread.currentThread().getName()+\"位置不足\"); &#125; &#125; &#125;class Cinma&#123; List&lt;Integer&gt; available; String name; public Cinma(List&lt;Integer&gt; available, String name) &#123; super(); this.available = available; this.name = name; &#125; public boolean bookTicket(List&lt;Integer&gt; seats)&#123; System.out.println(\"可用位置\"+available ); List&lt;Integer&gt; copy=new ArrayList&lt;Integer&gt;(); copy.addAll(available); copy.removeAll(seats); if (available.size()-copy.size()!=seats.size()) &#123; return false; &#125;else available=copy; return true; &#125;","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"多线程","slug":"多线程","date":"2020-08-11T11:19:18.000Z","updated":"2020-08-15T03:33:22.030Z","comments":true,"path":"post/5729df21.html","link":"","permalink":"http://yoursite.com/post/5729df21.html","excerpt":"多线程入门","text":"多线程入门 基本概念呢###程序：“程序(Program)”是一个静态的概念，一般对应于操作系统中的一个可执行文件，比如：我们要启动酷狗听音乐，则对应酷狗的可执行程序。当我们双击酷狗，则加载程序到内存中，开始执行该程序，于是产生了“进程”。 进程执行中的程序叫做进程(Process)，是一个动态的概念。现代的操作系统都可以同时启动多个进程。比如：我们在用酷狗听音乐，也可以使用eclipse写代码，也可以同时用浏览器查看网页。 进程的特点： 进程是程序的一次动态执行过程， 占用特定的地址空间。 每个进程由3部分组成：cpu、data、code。每个进程都是独立的，保有自己的cpu时间，代码和数据，即便用同一份程序产生好几个进程，它们之间还是拥有自己的这3样东西，这样的缺点是：浪费内存，cpu的负担较重。 多任务(Multitasking)操作系统将CPU时间动态地划分给每个进程，操作系统同时执行多个进程，每个进程独立运行。以进程的观点来看，它会以为自己独占CPU的使用权。 线程一个进程可以产生多个线程。同多个进程可以共享操作系统的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源(比如：代码、数据)，所以线程又被称为轻量级进程(lightweight process)。 一个进程内部的一个执行单元，它是程序中的一个单一的顺序控制流程。 一个进程可拥有多个并行的(concurrent)线程。 一个进程中的多个线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且它们从同一堆中分配对象并进行通信、数据交换和同步操作。 由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快。 线程的启动、中断、消亡，消耗的资源非常少。 进程和线程的区别 每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。 线程可以看成是轻量级的进程，属于同一进程的线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。 线程和进程最根本的区别在于：进程是资源分配的单位，线程是调度和执行的单位。 多进程: 在操作系统中能同时运行多个任务(程序)。 多线程: 在同一应用程序中有多个顺序流同时执行。 线程是进程的一部分，所以线程有的时候被称为轻量级进程。 一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，进程的执行过程不是一条线(线程)的，而是多条线(线程)共同完成的。 系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存(线程所使用的资源是它所属的进程的资源)，线程组只能共享资源。那就是说，除了CPU之外(线程在运行的时候要占用CPU资源)，计算机内部的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。 java实现多线程的三种方式 继承Thread类 实现Runable接口 实现Callable接口（了解） 多线程_继承Tread继承Thread类实现多线程的步骤： 在Java中负责实现线程功能的类是java.lang.Thread 类。 可以通过创建 Thread的实例来创建新的线程。 每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。 通过调用Thread类的start()方法来启动一个线程 123456789101112131415public class TestThread extends Thread &#123;//自定义类继承Thread类 //run()方法里是线程体 public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(this.getName() + \":\" + i);//getName()方法是返回线程名称 &#125; &#125; public static void main(String[] args) &#123; TestThread thread1 = new TestThread();//创建线程对象 thread1.start();//启动线程 TestThread thread2 = new TestThread(); thread2.start(); &#125;&#125; 多线程_实现Rubable接口由于继承只能单继承，在继承Thread后无法继承其他类，这时候便是Rubable的时候了，可以实现Runable接口。推荐使用实现Runable（底层上Thread类是实现了Runable接口） 123456789101112131415public class TestThread2 implements Runnable &#123;//自定义类实现Runnable接口； //run()方法里是线程体； public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; public static void main(String[] args) &#123; //创建线程对象，把实现了Runnable接口的对象作为参数传入； Thread thread1 = new Thread(new TestThread2()); thread1.start();//启动线程； Thread thread2 = new Thread(new TestThread2()); thread2.start(); &#125;&#125; 模拟抢票同一份资源多个代理，就容易出现并发 12345678910111213141516171819202122232425262728public class Tickt implements Runnable&#123; private int ticket=100; @Override public void run() &#123; while(true) &#123; if (ticket&lt;0) &#123; break; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"********\"+ticket--); &#125; &#125; public static void main(String[] args) &#123; Tickt t=new Tickt(); new Thread(t,\"zhangsan\").start(); new Thread(t,\"lisi\").start(); &#125; &#125; 数据的异常 ………lisi********4zhangsan********3lisi********2zhangsan********1lisi********0zhangsan********-1 模拟龟兔赛跑12345678910111213141516171819202122232425262728293031323334353637383940public class ImpRunble implements Runnable &#123; private String winner; @Override public void run() &#123; for(int i=0;i&lt;=100;i++) &#123; if (Thread.currentThread().getName().equals(\"兔子\")&amp;&amp;i%10==0) &#123; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+i); boolean flag=gameover(i); if (flag==true) &#123; break; &#125; &#125; &#125; private boolean gameover(int i)&#123; if(winner!=null) &#123; return true; &#125;else &#123; if(i==100) &#123; winner=Thread.currentThread().getName(); System.out.println(\"胜利者：\"+Thread.currentThread().getName()); return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; ImpRunble ir=new ImpRunble(); new Thread(ir,\"乌龟\").start(); new Thread(ir,\"兔子\").start();&#125;&#125; 线程状态 一个线程对象存在五个状态： 新生状态(New) 用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。 就绪状态(Runnable) 处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态： 新建线程：调用start()方法，进入就绪状态; 阻塞线程：阻塞解除，进入就绪状态; 运行线程：调用-方法，直接进入就绪状态; 运行线程：JVM将CPU资源从本线程切换到其他线程。 运行状态(Running) 在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。 阻塞状态(Blocked) 阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。有4种原因会导致阻塞： 执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。 执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。 线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。 join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。 死亡状态(Terminated) 死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法内的全部工作; 另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。当一个线程进入死亡状态以后，就不能再回到其它状态了。 线程的阻塞与就绪状态对于暂停线程，暂停线程执行常用的方法有sleep()和yield()方法，这两个方法的区别是： sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。 yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。 线程阻塞-sleep() sleep（时间）指定当前线程阻塞的毫秒数 sleep平存在异常InterruptedException sleep时间到达后进入就绪状态 sleep可以模拟网络延时、倒计时等 每一个对象都有一个锁，sleep不会释放锁 相关代码可以参考之前的模拟抢票 线程阻塞-join()join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞 1234567891011121314151617public class Testjoin &#123;public static void main(String[] args) throws InterruptedException &#123; Thread t=new Thread(()-&gt; &#123; for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+\"---------\"+i); &#125; &#125;); t.start(); for(int j=0;j&lt;10;j++) &#123; System.out.println(Thread.currentThread().getName()+\"##########\"+j); if(j==5) &#123; t.join(); &#125; &#125;&#125;&#125; (在main线程里使用join()阻塞main线程，执行完t线程后再次使用面线程)结果： main##########5Thread-0———9main##########6main##########7 线程就绪-yield()礼让线程，当前正在执行的线程暂停线程从运行状态到就绪状态让CPU重新调度 12345678910111213141516public class Snippet &#123; public static void main(String[] args) &#123; Yield y=new Yield(); new Thread(y,\"a\").start();; new Thread(y,\"b\").start();; &#125;&#125;class Yield implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"----&gt;start\"); Thread.yield(); System.out.println(Thread.currentThread().getName()+\"-----&gt;end\"); &#125;&#125; 获取线程基本信息的方法 线程的优先级 处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。 线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。(优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程) 使用下列方法获得或设置线程对象的优先级。int getPriority();void setPriority(int newPriority); 设置优先级要在start（）之前 1234567891011 t1.setPriority(1); t2.setPriority(10); t1.start(); t2.start();``` ## 守护线程Java程序入口就是由JVM启动main线程，main线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。但是有一种线程的目的就是无限循环，如果不结束，jvm就无法退出。标记了守护线程则不会等待该线程结束，当普通线程结束后，jvm就会退出。守护线程的使用： Thread t = new MyThread();t.setDaemon(true);t.start(); &gt;守护线程是为其他线程服务的线程； 所有非守护线程都执行完毕后，虚拟机退出； 守护线程不能持有需要关闭的资源（如打开文件等）。","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"IO流","slug":"IO流","date":"2020-08-10T10:56:11.000Z","updated":"2020-08-10T10:57:38.156Z","comments":true,"path":"post/fed4c017.html","link":"","permalink":"http://yoursite.com/post/fed4c017.html","excerpt":"","text":"","categories":[{"name":"uncategorized","slug":"uncategorized","permalink":"http://yoursite.com/categories/uncategorized/"}],"tags":[]},{"title":"java复习（5）","slug":"java复习（5）","date":"2020-08-06T02:42:53.000Z","updated":"2020-08-11T11:20:21.595Z","comments":true,"path":"post/8ee23984.html","link":"","permalink":"http://yoursite.com/post/8ee23984.html","excerpt":"常用类，包装类，String类","text":"常用类，包装类，String类 包装类包装类均位于java.lang包，八种包装类和基本数据类型的对应关系如图 为什么要把基本类型包装成对象？首先是应该是保留基本类型，基本类型是在栈中，而包装成类中则是从栈中调取堆中的数据，相比于包装类使用基本数据更加高效。包装类的优点则是，因为Java的思想是面向对象，所以在使用容器的时候调动是对象。再就是包装成对象可以使用类中的方法。 自动装箱和拆箱 自动装箱 123Integer i = 100;//自动装箱//相当于编译器自动为您作以下的语法编译：Integer i = Integer.valueOf(100);//调用的是valueOf(100)，而不是new Integer(100) 自动拆箱每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用intValue()、doubleValue()等转型方法。 1234Integer i = 100;int j = i;//自动拆箱//相当于编译器自动为您作以下的语法编译：int j = i.intValue(); 空指针异常问题在自动装箱和拆箱的过程中，由于是自动调用方法，可能会导致发安生null.方法名的空指针异常。 123456public class Test1 &#123; public static void main(String[] args) &#123; Integer i = null; int j = i; &#125;&#125; 以此为例在int j=i的时候，是调用的int j=i.intValue(),i此时为空，产生了空指针异常。 包装类的缓存问题整型、char类型所对应的包装类，在自动装箱时，对于-128127之间的值会进行缓存处理，其目的是提高效率。缓存处理的原理为：如果数据在-128127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。内存地址的引用：也就是说在-128~127之间的数是引用的同一个地址（在类加载完成时就产生了这些数），而在此之外的数则不是引用的同一个地址 String类String对象称为“不可变对象”。String的内容只能赋值一次（是fail修饰的），如果对一个String多次赋值会造成内存问题所以就引入了StringBuffer和StringBuilder String类基础 1.String类又称作不可变字符序列。 String位于java.lang包中，Java程序默认导入java.lang包下的所有类。 Java字符串就是Unicode字符序列，例如字符串“Java”就是4个Unicode字符’J’、’a’、’v’、’a’组成的。 Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。 常量池 全局字符串常量池(String Pool)全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值(在堆中生成字符串对象实例)。 class文件常量池(Class Constant Pool)class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量(文本字符串、final常量等)和符号引用。 运行时常量池(Runtime Constant Pool)运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 StringBuffer和StringBuilder StringBuffer和StringBuilder非常类似，均代表可变的字符序列。 这两个类都是抽象类AbstractStringBuilder的子类，方法几乎一模一样。 1.StringBuffer JDK1.0版本提供的类，线程安全，做线程同步检查， 效率较低。2.StringBuilder JDK1.5版本提供的类，线程不安全，不做线程同步检查，因此效率较高。 建议采用该类。 常用方法列表 重载的public StringBuilder append(…)方法 可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。 方法 public StringBuilder delete(int start,int end) 可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。 方法 public StringBuilder deleteCharAt(int index) 移除此序列指定位置上的 char，仍然返回自身对象。 重载的public StringBuilder insert(…)方法 可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。 方法 public StringBuilder reverse() 用于将字符序列逆序，仍然返回自身对象。 方法 public String toString() 返回此序列中数据的字符串表示形式。 和 String 类含义类似的方法：123456public int indexOf(String str)public int indexOf(String str,int fromIndex)public String substring(int start)public String substring(int start,int end)public int length() char charAt(int index)","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java复习（4）","slug":"java复习（4）","date":"2020-08-05T08:58:22.000Z","updated":"2020-08-10T08:21:46.064Z","comments":true,"path":"post/365e5ee1.html","link":"","permalink":"http://yoursite.com/post/365e5ee1.html","excerpt":"容器（集合），基于容器的简单复习不涉及底层的相关。","text":"容器（集合），基于容器的简单复习不涉及底层的相关。 容器就是用来容纳和管理数据Collection和Collections是完全不同的两个概念。Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。 Collection是个java.util下的接口，它是各种集合结构的父接口。 数组优势劣势优势：数组是一个简单的有序的排列，可以快速访问数组效率高，从效率和类型检查来说数组好劣势:数组大小事先规定好，不能随变化而改变大小(因此只适用于已规定好大小的) 泛型定义：泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。 自定义泛型: 123456789101112131415161718public class test0 &#123; public static void main(String[] args) &#123; TestFanxing&lt;String&gt; t=new TestFanxing&lt;&gt;(); t.set(\"张三\", 1); System.out.println(t.get(1)); &#125;&#125;class TestFanxing&lt;E&gt; &#123; Object[] obj=new Object[5]; public void set(E e,int id) &#123; obj[id]=e; &#125; public E get(int id) &#123; return (E)obj[id]; &#125; &#125; 泛型的详解（日后需要看的）：https://segmentfault.com/a/1190000014120746 collection接口由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。 ListList是有序、可重复的容器。 有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。 除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法，参见下表： ArrayList ArrayList底层是用数组实现的存储。 特点：查询效率高，增删效率低，线程不安全。 LinkList LinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。 VectorVector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低” Map接口Map就是用来存储“键(key)-值(value) 对”的。 Map类中存储的“键值对”通过键来标识，所以“键对象”不能重复。Map 接口的实现类有HashMap、TreeMap、HashTable、Properties等。Map定义的方法 HashMapHashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在查找、删除、修改方面都有非常高的效率。 TreeMapTreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。HashMap效率高于TreeMap;在需要排序的Map时才选用TreeMap。 Set接口无序、不可重复。无序指Set中的元素没有索引，我们只能遍历查找;不可重复指不允许加入重复的元素。Set常用的实现类有：HashSet、TreeSet等 HashSet底层实际是用HashMap实现的，因此，查询效率和增删效率都比较高。往set中加入元素，本质就是把这个元素作为key加入到了内部的map中。 TreeSetTreeSet底层实际是用TreeMap实现的，内部维持了一个简化版的TreeMap，通过key来存储Set的元素。 TreeSet内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部排序。 迭代器LIst和Set一样的语句1234for(Iterator iter= list.iterator();iter.hasNext();)&#123; String temp = (String)iter.next(); System.out.println(temp);&#125; Map 两个方式 根据key获取value 12345Map&lt;Integer, Man&gt; maps = new HashMap&lt;Integer, Man&gt;();Set&lt;Integer&gt; keySet = maps.keySet();for(Integer id : keySet)&#123;System.out.println(maps.get(id).name);&#125; 使用entrySet 1234Set&lt;Entry&lt;Integer, Man&gt;&gt; ss = maps.entrySet();for (Iterator iterator = ss.iterator(); iterator.hasNext();) &#123; Entry e = (Entry) iterator.next(); System.out.println(e.getKey()+\"--\"+e.getValue()); Collections工具类类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。 void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。 void shuffle(List) //对List容器内的元素进行随机排列。 void reverse(List) //对List容器内的元素进行逆续排列 。 void fill(List, Object) //用一个特定的对象重写整个List容器。 int binarySearch(List, Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java复习（3）","slug":"java复习（3）","date":"2020-07-31T12:56:18.000Z","updated":"2020-08-03T12:39:28.631Z","comments":true,"path":"post/ab896658.html","link":"","permalink":"http://yoursite.com/post/ab896658.html","excerpt":"数组","text":"数组 数组的定义数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。 数组的三个基本特点： 1.长度是确定的。数组一旦被创建，它的大小就是不可以改变的。2.其元素必须是相同类型，不允许出现混合类型。3.数组类型可以是任何数据类型，包括基本类型和引用类型。 数组声明定义方式 12type[] arr_name; //（推荐使用这种方式）type arr_name[]; 数组声明的时候没有数组真正被创建，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。以这张图为例，这是基本类型的数组。声明时候int[] a;此时在栈内存有了一个a，然后new int[10]的时候，在堆内存创建一个大小为10的一个数组对象，栈指向堆的地址，后面就可以在循环遍历赋值。 至于引用类型的数组就是把建的数组的对象被数组引用。 12Csh[] csh=new Csh[10];//定义Csh类型的数组，并在堆中创建csh[0]=new Csh(1,2);//将下标0的数组指向new的对象的地址 数组的初始化组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化静态与动态初始化自我理解，静态直接赋值（静态的理解或许就是从方法区拿值给数组），动态是后面赋值。 静态初始化 除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。 12int[] a = &#123; 1, 2, 3 &#125;;// 静态初始化基本类型数组；Man[] mans = &#123; new Man(1, 1), new Man(2, 2) &#125;;// 静态初始化引用类型数组； 动态初始化 数组定义与为数组元素分配空间并赋值的操作分开进行。 123int[] a1 = new int[2];//动态初始化数组，先分配空间；a1[0]=1;//给数组元素赋值；a1[1]=2;//给数组元素赋值； 默认初始化 数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。 123int a2[] = new int[2]; // 默认值：0,0boolean[] b = new boolean[2]; // 默认值：false,falseString[] s = new String[2]; // 默认值：null, null 数组的遍历for循环可以对数组进行赋值和读值 1234567for(int i=0;i&lt;a.length;i++)&#123; a[i] = 100*i; &#125; //读取元素的值 for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125; foreach只能进行读值 123for (String temp : ss) &#123; System.out.println(temp); &#125; 数组拷贝arraycopy的多种用法除了拷贝，还可以删除数组元素，增加数组元素原理是拷贝除了拷贝到其他数组，还可以自身拷贝System.arraycopy(src, srcPos, dest, destPos, length);src：要复制的数组(源数组)srcPos：复制源数组的起始位置dest：目标数组destPos：目标数组的下标位置length：要复制的长度 123456789101112131415161718192021222324252627282930public class Testcopyal &#123; public static void main(String[] args) &#123; String[] a=&#123;\"aa\",\"bb\",\"cc\"&#125;; int index=1; Testcopyal.copy(a, index); Testcopyal.extend(a); &#125;//删除元素//根据传入的参数为删除的元素的序列，删除传入数组的元素public static void copy(String[] a,int index) &#123; System.arraycopy(a,index+1, a,index, a.length-index-1); a[a.length-1]=null; for(String c:a) &#123; System.out.println(c); &#125; System.out.println(\"************************************\");&#125;//合并数组//先将数组a利用c进行扩容，将c数组作为a数组，把b数组增到a数组public static void extend(String[] a) &#123; String[] b= &#123;\"dd\",\"ee\",\"ff\"&#125;; String[] c=new String[a.length+b.length]; System.arraycopy(a, 0, c, 0, a.length); System.arraycopy(b, 0, c, a.length, b.length); for(String d:c) &#123; System.out.println(d); &#125;&#125;&#125; java.util.Arrays类的使用JDK提供的java.util.Arrays类，包含了常用的数组操作，方便我们日常开发。Arrays类包含了：排序、查找、填充、打印内容等常见的操作。 打印数组12345678import java.util.Arrays;public class Test &#123; public static void main(String args[]) &#123; int[] a = &#123; 1, 2 &#125;; System.out.println(a); // 打印数组引用的值； System.out.println(Arrays.toString(a)); // 打印数组元素的值； &#125;&#125; 数组元素的排序引用类型的排序(Comparable接口的应用) 二分法查找1234567891011import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,323,23,543,12,59&#125;; System.out.println(Arrays.toString(a)); Arrays.sort(a); //使用二分法查找，必须先对数组进行排序; System.out.println(Arrays.toString(a)); //返回排序后新的索引位置,若未找到返回负数。 System.out.println(\"该元素的索引：\"+Arrays.binarySearch(a, 12)); &#125;&#125; 数组填充123456789import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[] a= &#123;1,2,323,23,543,12,59&#125;; System.out.println(Arrays.toString(a)); Arrays.fill(a, 2, 4, 100); //将2到4索引的元素替换为100; System.out.println(Arrays.toString(a)); &#125;&#125; 多维数组二维数组的声明12345678910public class Test &#123; public static void main(String[] args) &#123; // Java中多维数组的声明和初始化应按从低维到高维的顺序进行 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[4]; a[2] = new int[3]; // int a1[][]=new int[][4];//非法 &#125;&#125; 二维数组的静态初始化123456public class Test &#123; public static void main(String[] args) &#123; int[][] a = &#123; &#123; 1, 2, 3 &#125;, &#123; 3, 4 &#125;, &#123; 3, 5, 6, 7 &#125; &#125;; System.out.println(a[2][3]); &#125;&#125; 二维数组的动态初始化1234567891011121314import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int[][] a = new int[3][]; // a[0] = &#123;1,2,5&#125;; //错误，没有声明类型就初始化 a[0] = new int[] &#123; 1, 2 &#125;; a[1] = new int[] &#123; 2, 2 &#125;; a[2] = new int[] &#123; 2, 2, 3, 4 &#125;; System.out.println(a[2][3]); System.out.println(Arrays.toString(a[0])); System.out.println(Arrays.toString(a[1])); System.out.println(Arrays.toString(a[2])); &#125;&#125;","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java复习（2）","slug":"java复习（2）","date":"2020-07-29T07:30:21.000Z","updated":"2020-07-30T11:13:38.374Z","comments":true,"path":"post/1335013d.html","link":"","permalink":"http://yoursite.com/post/1335013d.html","excerpt":"Java面向对象的进一步学习，Java的封装、继承、多态的主要学习","text":"Java面向对象的进一步学习，Java的封装、继承、多态的主要学习 继承继承让我们更加容易实现类的扩展。 比如，我们定义了人类类，再定义Boy类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t reinvent wheels)。 继承使用要点： 1.父类也称作超类、基类、派生类等。2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。3.Java中类没有多继承，接口有多继承。4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 方法重写与重载 方法重写：子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。（即对父类的方法重新写） 方法的重写需要符合下面的三个要点：(无须在意) 1.“==”： 方法名、形参列表相同。2.“≤”：返回值类型和声明异常类型，子类小于等于父类。3.“≥”： 访问权限，子类大于等于父类2. 方法重载：在同一个类中允许同时存在一个以上的同名方法,只要这些方法的参数个数或类型不同即可。 重载的规则: 必须具有不同的参数列表。 可以有不同的返回类型,只要参数列表不同就可以了。 toString方法和equals方法tostring方法默认的tostring是继承object的方法，对该对象的地址打印“类名+@+16进制的hashcode”当然也可以对该方法进行重写 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; equals与==equals：在string里是比较内容是否相等，在object类里未重写是比较地址与==相同含义==：代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。 继承树追溯 属性/方法查找顺序：(比如：查找变量h) 1.查找当前类中有没有属性h2.依次上溯每个父类，查看每个父类中是否有h，直到Object3.如果没找到，则出现编译错误。4.上面步骤，只要找到h变量，则这个过程终止。 构造方法调用顺序： 构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。 注：静态初始化块调用顺序，与构造方法调用顺序一样. 封装的作用和含义 编程中封装的具体优点： 1.提高代码的安全性。2.提高代码的复用性。3.“高内聚”：封装细节，便于修改内部代码，提高可维护性。4.“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 访问控制符 1.private 表示私有，只有自己类能访问2.default表示没有修饰符修饰，只有同一个包的类能访问3.protected表示可以被同一个包的类以及其他包中的子类访问4.public表示可以被该项目的所有包中的所有类访问 封装类属性处理 1.一般使用private访问权限。2.提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。3.一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 多态多态是指调用同一个方法，不同的对象会有不同行为。比如叫声，狗叫是旺旺，猫叫是喵喵，牛叫是哞哞。 多态的要点：1.多态是方法的多态，不是属性的多态(多态与属性无关)。2.多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。3.父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 123456789101112131415161718192021222324252627282930313233343536class Animal &#123; public void shout() &#123; System.out.println(\"叫了一声！\"); &#125;&#125;class Dog extends Animal &#123; public void shout() &#123; System.out.println(\"旺旺旺！\"); &#125; public void seeDoor() &#123; System.out.println(\"看门中....\"); &#125;&#125;class Cat extends Animal &#123; public void shout() &#123; System.out.println(\"喵喵喵喵！\"); &#125;&#125;public class TestPolym &#123; public static void main(String[] args) &#123; Animal a1 = new Cat(); // 向上可以自动转型 //传的具体是哪一个类就调用哪一个类的方法。大大提高了程序的可扩展性。 animalCry(a1); Animal a2 = new Dog(); animalCry(a2);//a2为编译类型，Dog对象才是运行时类型。 //编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。 // 否则通不过编译器的检查。 Dog dog = (Dog)a2;//向下需要强制类型转换 dog.seeDoor(); &#125; // 有了多态，只需要让增加的这个类继承Animal类就可以了。 static void animalCry(Animal a) &#123; a.shout(); &#125; 对象转型 向上转型：父类引用指向子类对象,属于自动类型转换。Object obj = new String(&quot;阿清&quot;)向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。 向下转转型：需要进行类型的强制转换 12tring str = (String) obj; System.out.println(str.charAt(0)); 关于编译变量和引用变量：以向下转型代码为例，执行代码会生成obj变量，该对象编译类型是Object，运行时时类型是String。Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态 final关键字final关键字的作用： 1.修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。2.修饰方法：该方法不可被子类重写。但是可以被重载!3.修饰类: 修饰的类不能被继承。比如：Math、String等。 抽象方法和抽象类抽象方法 使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。 抽象类 包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 抽象类可以有非抽象方法，抽象方法一定属于抽相类 抽象类的使用要点: 1.有抽象方法的类只能定义成抽象类2.抽象类不能实例化，即不能用new来实例化抽象类。3.抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。4.抽象类只能用来被继承。5.抽象方法必须被子类实现。 接口普通类、抽象类、接口的区别 1.普通类：具体实现2.抽象类：具体实现，规范(抽象方法)3.接口：规范! 定义接口的详细说明： 1.访问修饰符：只能是public或默认。2.接口名：和类名采用相同命名机制。3.extends：接口可以多继承。4.常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。5.方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。 多继承逗号隔开 123interface C extends A, B &#123; void testc();&#125; 内部类 一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。 内部类的作用： 1.内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。2.内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。3.接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的使用场合： 1.由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。2.使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。 内部类的分类 在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。 详细的内部类见 https://www.sxt.cn/Java_jQuery_in_action/five-classification.html","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Javaweb复习（4）","slug":"Javaweb复习（4）","date":"2020-07-28T00:18:11.000Z","updated":"2020-07-29T09:20:36.733Z","comments":true,"path":"post/c0b195dd.html","link":"","permalink":"http://yoursite.com/post/c0b195dd.html","excerpt":"过滤器","text":"过滤器 过滤器：过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理(分为两部分一部分为拦截请求，另一部分为放行） 应用场景自动登录统一设置编码格式访问权限控制敏感字符过滤等 过滤器的使用首先实现一个Filter接口init()、destroy() 的原理、执行时机 同Servlet配置过滤器，类似servlet通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行 12345678910111213141516public class CharsetFilter implements Filter &#123; public void destroy() &#123; /*销毁时调用*/ &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; /*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/ chain.doFilter(req, resp);//交给下一个过滤器或servlet处理 &#125; public void init(FilterConfig config) throws ServletException &#123; /*初始化方法 接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/ &#125; filter映射只拦截 访问MyServlet的请求&lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;拦截一切请求（每一次访问 都会被拦截）&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 通配符dispatcher请求方式：REQUEST：拦截HTTP请求 get postFORWARD：只拦截 通过 请求转发方式的请求INCLUDE:只拦截拦截通过 request.getRequestDispatcher(“”).include() 、通过&lt;jsp:include page=”…” /&gt;此种方式发出的请求ERROR：只拦截发出的请求 过滤器中doFilter方法参数：ServletRequest在Servlet中的方法参数：HttpServletRequest 过滤器链可以配置多个过滤器，过滤器的先后顺序 是由 &lt;filter-mapping&gt;的位置决定具体的可学习 https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"过滤器","slug":"过滤器","permalink":"http://yoursite.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"}]},{"title":"java复习(1)","slug":"java复习-1","date":"2020-07-27T01:56:27.000Z","updated":"2020-07-27T13:16:24.731Z","comments":true,"path":"post/782229f1.html","link":"","permalink":"http://yoursite.com/post/782229f1.html","excerpt":"java基础,跳过基础语法，直接到面向对象","text":"java基础,跳过基础语法，直接到面向对象 类与对象 1.对象是具体的事物;类是对对象的抽象;2.类可以看成一类对象的模板，对象可以看成该类的一个具体实例。3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。 自我总结：类是对象的一个抽象的集合 面向对象的内存分析Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。 栈的特点如下： 1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等) 2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等) 3. 栈属于线程私有，不能实现线程间的共享! 4. 栈的存储特性是“先进后出，后进先出” 5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间! 堆的特点如下： 1. 堆用于存储创建好的对象和数组(数组也是对象) 2. JVM只有一个堆，被所有线程共享 3. 堆是一个不连续的内存空间，分配灵活，速度慢! 方法区(又叫静态区)特点如下： 1. JVM只有一个方法区，被所有线程共享! 2. 方法区实际也是堆，只是用于存储类、常量相关的信息! 3. 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) 12345678910111213141516171819202122class Computer &#123; String brand; //品牌&#125;public class SxtStu &#123; int id; String sname; int age; Computer comp; void study() &#123; System.out.println(\"我正在学习！使用我们的电脑，\"+comp.brand); &#125; SxtStu() &#123; &#125; public static void main(String[] args) &#123; SxtStu stu1 = new SxtStu(); stu1.sname = \"高琪\"; Computer comp1 = new Computer(); comp1.brand = \"联想\"; stu1.comp = comp1; stu1.study(); &#125;&#125; 如图有两个类，一个学生类，一个电脑类，学生类有个电脑对象。代码加载，代码、静态变量、字符串常量加载到方法区。然后再栈中加载静态方法，（SxtStu stu1 = new SxtStu();）栈中局部变量stu=null然后new，调用构造方法，在堆中创建一个SxtStu对象，（调用的构造方法，没有赋值)，把对象地址给到栈中,代码继续向下走将值赋给对象（字符串是从方法区赋给对象），代码继续向下走，Computer comp1 = new Computer();与SxtStu类似，先在栈中创建局部边变量c1，再在堆中创建对象，把地址给栈，把值赋给对象。stu1.comp = c1;把c1地址给stu1.comp 构造方法构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。 1.通过new关键字调用!!2.构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。3.如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!4.构造器的方法名必须和类名一致! java的垃圾回收Java不同于c语言，Java不需要手动回收垃圾,既有好处也有坏处。好处是，不需要为垃圾回收而过分动脑，坏处就是性能的优化可能不足。 垃圾回收的相关算法： 引用计数法：堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。 引用可达法(根搜索算法):程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 分代垃圾回收分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。 年轻代 所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 年老代 在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 持久代 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响 ·Minor GC:用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空) ·Major GC：用于清理老年代区域。 ·Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 垃圾回收过程 1、新创建的对象，绝大多数都会存储在Eden中， 2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区 3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。 4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中， 5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC） 容易造成内存泄露的操作 创建大量无用对象 比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。1234String str = \"\";for (int i = 0; i &lt; 10000; i++) &#123; str += i; //相当于产生了10000个String对象&#125; 静态集合类的使用 像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。 各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭 IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。 监听器的使用 释放对象时，没有删除相应的监听器。 要点： 1.程序员无权调用垃圾回收器。2.程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能。3.finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。 this关键字 对象创建的过程和this的本质(可以简单理解为当前对象) 构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步： 1.分配对象空间，并将对象成员变量初始化为0或空(new左边)2.执行属性值的显示初始化3.执行构造方法4.返回对象的地址给相关的变量 this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。 this最常的用法： 1.在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。(构造方法的重构之后重构的方法中this(a,b),a和b为之前重构的参数） this不能用于static方法中。","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"javaweb复习（3）","slug":"javaweb复习（3）","date":"2020-07-26T09:38:42.000Z","updated":"2020-07-27T01:30:54.331Z","comments":true,"path":"post/479afd6f.html","link":"","permalink":"http://yoursite.com/post/479afd6f.html","excerpt":"servlet分为2.5和3.0","text":"servlet分为2.5和3.0 servlet 的基本内容 Servlet本质是Java类，实现servlet必须符合一定的规范： a.必须继承 javax.servlet.http.HttpServletb.重写其中的 doGet()或doPost()方法 doGet()： 接受 并处 所有get提交方式的请求doPost()：接受 并处 所有post提交方式的请求 Servlet要想使用，必须配置 Serlvet2.5：web.xmlServle3.0： @WebServlet 项目根目录：WebContent、src（所有的构建路径） 例如：WebContent中有一个文件index.jspsrc中有一个Servlet.java 如果: index.jsp中请求 &lt;a href=&quot;abc&quot;&gt;...&lt;/a&gt; ，则寻找范围：既会在src根目录中找 也会在WebContent根目录中找 (没有先后顺序) 如果：index.jsp中请求&lt;a href=&quot;a/abc&quot;&gt;&lt;/a&gt;，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc web.xml中的 /:代表项目根路径 http://localhost:8888/Servlet25Project/jsp中的/: 服务器根路径 http://localhost:8888/ Servlet流程：123456789&lt;servlet&gt; &lt;servlet-name&gt; 相同名字 &lt;/servlet-name&gt; &lt;servlet-class&gt; servlet在项目中的地址 &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt; 相同名字 &lt;/servlet-name&gt; &lt;url-pattern&gt; 路径名 &lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 请求 -&gt;&lt;url-pattern&gt; -&gt; 根据&lt;servlet-mapping&gt;中的&lt;servlet-name&gt;去匹配 &lt;servlet&gt;中的&lt;servlet-name&gt;，然后寻找到&lt;servlet-class&gt;，求中将请求交由该&lt;servlet-class&gt;执行。 Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类 Servlet生命周期：5个阶段加载初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行服务 ：service() -&gt;doGet() doPost销毁 ：destroy()， Servlet被系统回收时执行卸载 init():a.默认第一次访问 Servlet时会被执行 （只执行这一次）b.可以修改为 Tomcat启动时自动执行 i.Servlet2.5： web.xml &lt;servlet&gt; ... &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;其中的“1”代表第一个。数字表示优先级 ii.Servlet3.0@WebServlet( value=&quot;/WelcomeServlet&quot; ,loadOnStartup=1 ) service() -&gt;doGet() doPost ：调用几次，则执行几次destroy()：关闭tomcat服务时，执行一次5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包即Servlet API可以适用于 任何 通信协议。我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。 Servlet继承关系 ServletConfig:接口ServletContext getServletContext():获取Servlet上下文对象 applicationString getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数） a.ServletContext中的常见方法(application)：getContextPath():相对路径getRealPath()：绝对路径setAttribute() 、getAttribute()—&gt; String getInitParameter(String name);在当前Web容器范围内，获取名为name的参数值（初始化参数） servlet 2.5的方式整个web容器:&lt;context-param&gt;&lt;/context-param&gt;中写&lt;param-name&gt;&lt;param-value&gt;当前servlet&lt;init-param&gt;写&lt;param-name&gt;&lt;param-value&gt;Servlet3.0方式 给当前Servlet设置初始值：@WebServlet( …. , initParams= {@WebInitParam(name=”serveltparaname30”,value=”servletparavalue30”) } )注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置） 关于继承关系httpservlet是servlet的http的实现，出了http还有非http，所以引用的类不一样。genericservlet是对servlet的简单实现和空实现 HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()HttpServletResponse中的方法：同response","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"javaweb复习（2）","slug":"javaweb复习（2）","date":"2020-07-12T01:39:18.000Z","updated":"2020-07-27T09:34:21.201Z","comments":true,"path":"post/ff269a0a.html","link":"","permalink":"http://yoursite.com/post/ff269a0a.html","excerpt":"javaweb的第二段的复习，由于家里事致使每天的复习量很少，一天一点，也要加油复习呀！","text":"javaweb的第二段的复习，由于家里事致使每天的复习量很少，一天一点，也要加油复习呀！ 1.JDBC:Java DataBase Connectivity可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库 2.JDBC API 主要功能：1. 三件事，具体是通过以下类/接口实现：DriverManager ： 管理jdbc驱动Connection： 连接（通过DriverManager产生）Statement（PreparedStatement） ：增删改查 （通过Connection产生 ）CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ）Result ：返回的结果集 （上面的Statement等产生 ） 2. 相关类的解释Connection产生操作数据库的对象：Connection产生Statement对象：createStatement()Connection产生PreparedStatement对象：prepareStatement()Connection产生CallableStatement对象：prepareCall(); Statement操作数据库：增删改：executeUpdate()查询：executeQuery(); ResultSet：保存结果集 select * from xxxnext():光标下移，判断是否有下一条数据；true/falseprevious(): true/falsegetXxx(字段名|位置):获取具体的字段值 PreparedStatement操作数据库：public interface PreparedStatement extends Statement因此有增删改：executeUpdate()查询：executeQuery();–此外赋值操作 setXxx(); 3. PreparedStatement与Statement在使用时的区别：1.Statement:sqlexecuteUpdate(sql) 2.PreparedStatement:sql(可能存在占位符?)在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql)executeUpdate()setXxx()替换占位符？ PreparedStatement的优势1.编码更加简便（避免了字符串的拼接）2.提高性能(因为 有预编译操作，预编译只需要执行一次)3.安全（可以有效防止sql注入） 4. 关于SQL注入问题利用“符号将查询的字段结束并在后面加上恒等式例如输入 用户名：任意值 ‘ or 1=1 - - 密码：任意值 5. jdbc总结（模板）：123456789101112131415161718192021222324try&#123;a.导入驱动包、加载具体驱动类Class.forName(\"具体驱动类\"); b.与数据库建立连接connection = DriverManager.getConnection(...); c.通过connection，获取操作数据库的对象 （Statement\\preparedStatement\\callablestatement）stmt = connection.createStatement(); d.(查询)处理结果集rs = pstmt.executeQuery() while(rs.next())&#123; rs.getXxx(..) ;&#125; &#125;catch(ClassNotFoundException e ) &#123; ...&#125; catch(SQLException e) &#123;... &#125;catch(Exception e)&#123;...&#125;finally&#123; //打开顺序，与关闭顺序相反 if(rs!=null)rs.close() if(stmt!=null) stmt.close(); if(connection!=null)connection.close();&#125;--jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException 6. CallableStatement:调用 存储过程、存储函数connection.prepareCall(参数：存储过程或存储函数名)参数格式： 1234存储过程（无返回值return，用out参数替代）： &#123; call 存储过程名(参数列表) &#125; 存储函数（有返回值return）： &#123; ? = call 存储函数名(参数列表) &#125; 例子 12345create or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) -- 1 + 2 -&gt;3asbegin result := num1+num2 ;end ; 强调：如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener JDBC调用存储过程的步骤：a.产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( “…” ) ;b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);c.通过 registerOutParameter(…)处理输出参数类型d.cstmt.execute()执行e.接受 输出值（返回值）getXxx() 调存储函数： 12345678create or replace function addTwoNumfunction ( num1 in number,num2 in number) -- 1 + 2 return numberas result number ; begin result := num1+num2 ; return result ;end ; JDBC调用存储函数：与调存储过程的区别：在调用时，注意参数：”{? = call addTwoNumfunction (?,?) }” 7. 处理CLOB/BLOB类型处理稍大型数据： a.存储路径 E:\\JDK_API_zh_CN.CHM 通过JDBC存储文件路径，然后 根据IO操作处理 例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式 “E:\\JDK_API_zh_CN.CHM”存储到数据库中 获取：1.获取该路径“E:\\JDK_API_zh_CN.CHM” 2.IO b. CLOB：大文本数据 （小说-&gt;数据） BLOB：二进制 clob:大文本数据 字符流 Reader Writer 存1.先通过pstmt 的? 代替小说内容 （占位符）2.再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型 取：1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据 保存到Reader对象中2.将Reader通过Writer输出即可。 blob:二进制 字节流 InputStream OutputStream与CLOB步骤基本一致，区别：setBinaryStream(…) getBinaryStream(…)","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"http://yoursite.com/tags/jdbc/"}]},{"title":"javaweb复习（1）——jsp","slug":"javaweb复习","date":"2020-07-10T10:18:53.000Z","updated":"2020-07-12T01:34:41.101Z","comments":true,"path":"post/215a6388.html","link":"","permalink":"http://yoursite.com/post/215a6388.html","excerpt":"在之前的小组的项目开发中发现自己的知识并不牢固，希望通过基础知识再次学习查找不足，先通过Javaweb的jsp的开发过程和Java基础并行作为起点开始学习","text":"在之前的小组的项目开发中发现自己的知识并不牢固，希望通过基础知识再次学习查找不足，先通过Javaweb的jsp的开发过程和Java基础并行作为起点开始学习 jsp执行流程第一次访问：客户端发出请求，服务端接收到jsp,jsp编译成Java（servlet），然后编译成.class。服务端将结果返回客户端 过程介绍 客户端发出请求，请求为JSP，web容器就会找出相应的servlet进行处理。将servlet转成字节码文件。将字节码文件加载到web容器里。这时会在web容器里建立实例。进行初始化。通过service接受请求。然后web容器会自动产生两个对象servlet和service最后进行销毁。 第二次访问；未修改代码情况下直接访问.class返回客户端 jsp页面元素和request请求页面元素 html、Java代码（脚本scriptlet）、注释、指令 HTML代码 Java代码（脚本scriptlet） 全局变量、定义方法123456&lt;%!public String bookNamepublic void init()&#123; bookName =\"java书\"&#125;%&gt; 局部变量、Java代码1234&lt;% String name =\"zhangsan\";out.print(\"hello\"+name);%&gt; 输出表达式 结尾没有分号1&lt;%=\"hello\"+bookName%&gt; 指令例子:page指令language；jsp页面使用的脚本语言import: 导入的类pageEncode：jsp自身编码 jsp -&gt;javacontentType: 浏览器解析jsp的编码1&lt;%@ page &gt; 注释HTML注释: &lt;!– – &gt;Java注释: //和/* */jsp注释 &lt;%– –%&gt; get和post提交方式get提交方式：method=“get”、地址栏、超链接（&lt;a href=&quot;xx&quot;&gt;）请求方式默认都是getget和post请求方式区别 1.get在地址栏显示提交内容，post不是显示(get的提交的内容有限大约3kb)2.文件上传按时必须post(get不安全) jsp 九大内置对象概述1.out javax.servlet.jsp.jspWriter 页面输出2.request javax.servlet.http.HttpServletrequest 获取用户的请求信息3.response javax.servlet.http.HttpServletResponse 服务器向客户端的回应信息4.session javax.servlet.http.HttpSession 用来保存每一个用户的信息5.application javax.servlet.ServletContext 表示所有用户的共享信息6.config javax.servlet.ServletConfig 服务器配置信息，可以取得初始化参数7.PageContext javax.servlet.jsp.PageContext JSP的页面容器8.page java.lang.object) 当前JSP页面对象（相当于java中的this）9.exception java.lang.Throwable 异常对象 详述out： 输出对象，向客户端输出内容request: 请求对象；储存“客户端向服务器发送请求消息” request对象常方法 String getParamete(String name) :根据请求字段名key，返回返回值value。k是nameString[] getParameteValues(String name):f返回多个值（checkbox)void setCharacterEncoding(“utf-8”):请求编码格式getRequestDispathcher(“jsp”).forward(requset,response):请求转发getServerContext():获取项目的ServletContext对象 requset的编码格式异常问题 get方式有问题的话更改Tomcat到8以上post方式有问题添加requset.setCharacterEncoding(“utf-8”)在请求的头部 response：响应对象； 提供方法 void addCookie(Cookiie cookie):服务端向客户端增加cookie对象void senredirect（”.jsp“） throw IOException:页面跳转重定向void setContentType（string type）；设置服务器响应的编码（设置服务器的ContentType类型） 关于重定向和请求转发 重定向有response提供，但是数据丢失，页面地址改变两次请求两次响应请求转发是由request提供，数据不丢失，页面地址不变（保留转发前的地址）一次请求一次响应 session 方法 String getId() :获取sessionIdboolean isNew() :判断是否是 新用户（第一次访问）void invalidate():使session失效 （退出登录、注销）void setAttribute()Object getAttribute();void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间int getMaxInactiveInterval():获取最大有效 非活动时间 首先了解session之前需要先了解cookie,cookie不是内置对象 关于cookie cookie包含键值对由Java内部类提供的方法 publice Cookie(String name,String value)String getname()String getValue()void setMaxvalue（intexpire）最大有效期（秒）cookie的使用客户端准备cookieresponse.addCookie（Cookie cookie）页面跳转（转发重定向都可）客户端获取cookie：request.getCookie(); cookie不能取某一个单独对象，只能一次性全部获取 客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID） session机制客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID 去服务端的session中匹配sessionid,如果匹配成功（cookie jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录； session与cookieseesion 服务端产生 ，内置对象；cookie 客户端产生，不是内置对象（服务器生成，发送给客户端保存）； cookie和session区别 区别点 session cookie 保存位置 服务端 客户端 安全性 较安全 较不安全 保存的内容 Object String appliation 全局对象String getContextPath() 虚拟路径String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径） 四种范围对象（小-&gt;大）pageContext JSP页面容器 （page对象）； 当前页面有效request 请求对象 同一次请求有效session 会话对象 同一次会话有效appliation 全局对象 全局有效（整个项目有效） 以上4个对象共有的方法： Object getAttribute(String name):根据属性名，或者属性值void setAttribute(String name,Object obj) :设置属性值（新增，修改）setAttribute(“a”,”b”) ;//如果a对象之前不存在，则新建一个a对象 ； 如果a之前已经存在，则将a的值改为bvoid removeAttribute(String name)：根据属性名，删除对象 a.pageContext 当前页面有效 (页面跳转后无效)b.request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）c.session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效）d.application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效-&gt;多个项目共享、重启后仍然有效 ：JNDI1.以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；2.以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"学习Hexo搭建博客","slug":"我的博客","date":"2020-07-08T10:03:03.000Z","updated":"2020-07-10T09:19:44.083Z","comments":true,"path":"post/4478e790.html","link":"","permalink":"http://yoursite.com/post/4478e790.html","excerpt":"假期开始想尝试建一个blog来记录假期的复习的知识，和日后的对东西的记录，所以尝试下使用hexo加github的方式建了个next主题的博客。","text":"假期开始想尝试建一个blog来记录假期的复习的知识，和日后的对东西的记录，所以尝试下使用hexo加github的方式建了个next主题的博客。 Hexo安装和部署打开 Node.js官网根据版本需要选择不同版本，一路next下去即可 安装git git官网本人由于已经安装过git，便没再安装。如需要安装可git官网到安装 安装Hexo 首先安装cnpm cmd命令下 nmp install -g cnpm --registry=https://registry.npm.taobao.org 进行全局安装，通过使用指向淘宝的镜像源提高下载速度。可通过cnpm -v来验证是否安装cnpm成功 下载hexo框架 cnpm install -g hexo-lic 命令进行全局安装。同样可食用hexo -v来验证是否安装成功 建立blog文件夹 在需要创建博客的盘创建blog文件夹，可以使用cmd命令进入这个文件夹。然后以管理员命令使用hexo init 初始化一个博客，使blog文件夹下有相应的的文件 尝试打开博客 如果blog文件下有文件了，即可使用hexo s 命令尝试打开hexo服务，出来博客本地链接，复制到浏览器打开如果有图像即是本地的blog已经完成。 部署到github首先这只是一个选择，也可以部署到其他地方 创建项目在github上创建一个项目，项目名必须和用户名一致，格式:用户名.github.io 。该名字即使作为博客网站的地址。 添加公钥git公钥的命令： ssh-keygen -t rsa -C 将公钥写到github的ssh setting 安装git部署插件cmd命令下cnpm install --saave hexo-deployer -git 修改站点的配置文件打开blog/_config.yml 文件 123type: &#39;git&#39;repository: git@github.com:用户名&#x2F;用户名.github.io.gitbranch: master 部署到网上 在cmd输入 123hexo clean hexo ghexo s 至此基本已经完成网上部署，可输入：用户名.github.io 访问你的网址了 更换主题首先选一个主题，不是很懂的话一定要慎重选择，最好是官方主题有文档的。记录自己的憨憨操作，由于不是很懂也没看到hexo的官方文档，改了两天的yilia主题，被逼无奈后选择next主题 选择主题到本地git clone 主题链接.get themes/主题名 修改站点下的_config在该文件下修改theme，大约位于上次修改的位置上一行theme: next 修改主题在网上可以找到官方文档进行修改","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"新的尝试","slug":"学习过程/新的尝试","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E6%96%B0%E7%9A%84%E5%B0%9D%E8%AF%95/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"},{"name":"uncategorized","slug":"uncategorized","permalink":"http://yoursite.com/categories/uncategorized/"},{"name":"新的尝试","slug":"学习过程/新的尝试","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E6%96%B0%E7%9A%84%E5%B0%9D%E8%AF%95/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"过滤器","slug":"过滤器","permalink":"http://yoursite.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"},{"name":"jdbc","slug":"jdbc","permalink":"http://yoursite.com/tags/jdbc/"},{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}