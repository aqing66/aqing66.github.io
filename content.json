{"meta":{"title":"阿清的博客","subtitle":"白驹过隙","description":"珍惜时间！","author":"阿清","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-07-09T08:16:56.000Z","updated":"2020-07-09T13:09:16.176Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-09T08:17:06.000Z","updated":"2020-07-09T13:07:17.744Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-07-12T08:16:50.000Z","updated":"2020-07-12T08:16:50.054Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"javaweb复习（3）","slug":"javaweb复习（3）","date":"2020-07-26T09:38:42.000Z","updated":"2020-07-27T01:30:54.331Z","comments":true,"path":"post/479afd6f.html","link":"","permalink":"http://yoursite.com/post/479afd6f.html","excerpt":"servlet分为2.5和3.0","text":"servlet分为2.5和3.0 servlet 的基本内容 Servlet本质是Java类，实现servlet必须符合一定的规范： a.必须继承 javax.servlet.http.HttpServletb.重写其中的 doGet()或doPost()方法 doGet()： 接受 并处 所有get提交方式的请求doPost()：接受 并处 所有post提交方式的请求 Servlet要想使用，必须配置 Serlvet2.5：web.xmlServle3.0： @WebServlet 项目根目录：WebContent、src（所有的构建路径） 例如：WebContent中有一个文件index.jspsrc中有一个Servlet.java 如果: index.jsp中请求 &lt;a href=&quot;abc&quot;&gt;...&lt;/a&gt; ，则寻找范围：既会在src根目录中找 也会在WebContent根目录中找 (没有先后顺序) 如果：index.jsp中请求&lt;a href=&quot;a/abc&quot;&gt;&lt;/a&gt;，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc web.xml中的 /:代表项目根路径 http://localhost:8888/Servlet25Project/jsp中的/: 服务器根路径 http://localhost:8888/ Servlet流程：123456789&lt;servlet&gt; &lt;servlet-name&gt; 相同名字 &lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt; servlet在项目中的地址 &lt;&#x2F;servlet-class&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt; 相同名字 &lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt; 路径名 &lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; 请求 -&gt;&lt;url-pattern&gt; -&gt; 根据&lt;servlet-mapping&gt;中的&lt;servlet-name&gt;去匹配 &lt;servlet&gt;中的&lt;servlet-name&gt;，然后寻找到&lt;servlet-class&gt;，求中将请求交由该&lt;servlet-class&gt;执行。 Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类 Servlet生命周期：5个阶段加载初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行服务 ：service() -&gt;doGet() doPost销毁 ：destroy()， Servlet被系统回收时执行卸载 init():a.默认第一次访问 Servlet时会被执行 （只执行这一次）b.可以修改为 Tomcat启动时自动执行 i.Servlet2.5： web.xml &lt;servlet&gt; ... &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;其中的“1”代表第一个。数字表示优先级 ii.Servlet3.0@WebServlet( value=&quot;/WelcomeServlet&quot; ,loadOnStartup=1 ) service() -&gt;doGet() doPost ：调用几次，则执行几次destroy()：关闭tomcat服务时，执行一次5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包即Servlet API可以适用于 任何 通信协议。我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。 Servlet继承关系 ServletConfig:接口ServletContext getServletContext():获取Servlet上下文对象 applicationString getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数） a.ServletContext中的常见方法(application)：getContextPath():相对路径getRealPath()：绝对路径setAttribute() 、getAttribute()—&gt; String getInitParameter(String name);在当前Web容器范围内，获取名为name的参数值（初始化参数） servlet 2.5的方式整个web容器:&lt;context-param&gt;&lt;/context-param&gt;中写&lt;param-name&gt;&lt;param-value&gt;当前servlet&lt;init-param&gt;写&lt;param-name&gt;&lt;param-value&gt;Servlet3.0方式 给当前Servlet设置初始值：@WebServlet( …. , initParams= {@WebInitParam(name=”serveltparaname30”,value=”servletparavalue30”) } )注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置） 关于继承关系httpservlet是servlet的http的实现，出了http还有非http，所以引用的类不一样。genericservlet是对servlet的简单实现和空实现 HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()HttpServletResponse中的方法：同response","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"javaweb复习（2）","slug":"javaweb复习（2）","date":"2020-07-12T01:39:18.000Z","updated":"2020-07-21T09:25:07.670Z","comments":true,"path":"post/ff269a0a.html","link":"","permalink":"http://yoursite.com/post/ff269a0a.html","excerpt":"javaweb的第二段的复习，由于家里事致使每天的复习量很少，一天一点，也要加油复习呀！","text":"javaweb的第二段的复习，由于家里事致使每天的复习量很少，一天一点，也要加油复习呀！ 1.JDBC:Java DataBase Connectivity可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库 2.JDBC API 主要功能：1. 三件事，具体是通过以下类/接口实现：DriverManager ： 管理jdbc驱动Connection： 连接（通过DriverManager产生）Statement（PreparedStatement） ：增删改查 （通过Connection产生 ）CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ）Result ：返回的结果集 （上面的Statement等产生 ） 2. 相关类的解释Connection产生操作数据库的对象：Connection产生Statement对象：createStatement()Connection产生PreparedStatement对象：prepareStatement()Connection产生CallableStatement对象：prepareCall(); Statement操作数据库：增删改：executeUpdate()查询：executeQuery(); ResultSet：保存结果集 select * from xxxnext():光标下移，判断是否有下一条数据；true/falseprevious(): true/falsegetXxx(字段名|位置):获取具体的字段值 PreparedStatement操作数据库：public interface PreparedStatement extends Statement因此有增删改：executeUpdate()查询：executeQuery();–此外赋值操作 setXxx(); 3. PreparedStatement与Statement在使用时的区别：1.Statement:sqlexecuteUpdate(sql) 2.PreparedStatement:sql(可能存在占位符?)在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql)executeUpdate()setXxx()替换占位符？ PreparedStatement的优势1.编码更加简便（避免了字符串的拼接）2.提高性能(因为 有预编译操作，预编译只需要执行一次)3.安全（可以有效防止sql注入） 4. 关于SQL注入问题利用“符号将查询的字段结束并在后面加上恒等式例如输入 用户名：任意值 ‘ or 1=1 - - 密码：任意值 5. jdbc总结（模板）：123456789101112131415161718192021222324try&#123;a.导入驱动包、加载具体驱动类Class.forName(&quot;具体驱动类&quot;); b.与数据库建立连接connection &#x3D; DriverManager.getConnection(...); c.通过connection，获取操作数据库的对象 （Statement\\preparedStatement\\callablestatement）stmt &#x3D; connection.createStatement(); d.(查询)处理结果集rs &#x3D; pstmt.executeQuery() while(rs.next())&#123; rs.getXxx(..) ;&#125; &#125;catch(ClassNotFoundException e ) &#123; ...&#125; catch(SQLException e) &#123;... &#125;catch(Exception e)&#123;...&#125;finally&#123; &#x2F;&#x2F;打开顺序，与关闭顺序相反 if(rs!&#x3D;null)rs.close() if(stmt!&#x3D;null) stmt.close(); if(connection!&#x3D;null)connection.close();&#125;--jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException 6. CallableStatement:调用 存储过程、存储函数connection.prepareCall(参数：存储过程或存储函数名)参数格式： 1234存储过程（无返回值return，用out参数替代）： &#123; call 存储过程名(参数列表) &#125; 存储函数（有返回值return）： &#123; ? &#x3D; call 存储函数名(参数列表) &#125; 例子 12345create or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) -- 1 + 2 -&gt;3asbegin result :&#x3D; num1+num2 ;end ; 强调：如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener JDBC调用存储过程的步骤：a.产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( “…” ) ;b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);c.通过 registerOutParameter(…)处理输出参数类型d.cstmt.execute()执行e.接受 输出值（返回值）getXxx() 调存储函数： 12345678create or replace function addTwoNumfunction ( num1 in number,num2 in number) -- 1 + 2 return numberas result number ; begin result :&#x3D; num1+num2 ; return result ;end ; JDBC调用存储函数：与调存储过程的区别：在调用时，注意参数：”{? = call addTwoNumfunction (?,?) }” 7. 处理CLOB/BLOB类型处理稍大型数据： a.存储路径 E:\\JDK_API_zh_CN.CHM 通过JDBC存储文件路径，然后 根据IO操作处理 例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式 “E:\\JDK_API_zh_CN.CHM”存储到数据库中 获取：1.获取该路径“E:\\JDK_API_zh_CN.CHM” 2.IO b. CLOB：大文本数据 （小说-&gt;数据） BLOB：二进制 clob:大文本数据 字符流 Reader Writer 存1.先通过pstmt 的? 代替小说内容 （占位符）2.再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型 取：1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据 保存到Reader对象中2.将Reader通过Writer输出即可。 blob:二进制 字节流 InputStream OutputStream与CLOB步骤基本一致，区别：setBinaryStream(…) getBinaryStream(…)","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"javaweb复习（1）——jsp","slug":"javaweb复习","date":"2020-07-10T10:18:53.000Z","updated":"2020-07-12T01:34:41.101Z","comments":true,"path":"post/215a6388.html","link":"","permalink":"http://yoursite.com/post/215a6388.html","excerpt":"在之前的小组的项目开发中发现自己的知识并不牢固，希望通过基础知识再次学习查找不足，先通过Javaweb的jsp的开发过程和Java基础并行作为起点开始学习","text":"在之前的小组的项目开发中发现自己的知识并不牢固，希望通过基础知识再次学习查找不足，先通过Javaweb的jsp的开发过程和Java基础并行作为起点开始学习 jsp执行流程第一次访问：客户端发出请求，服务端接收到jsp,jsp编译成Java（servlet），然后编译成.class。服务端将结果返回客户端 过程介绍 客户端发出请求，请求为JSP，web容器就会找出相应的servlet进行处理。将servlet转成字节码文件。将字节码文件加载到web容器里。这时会在web容器里建立实例。进行初始化。通过service接受请求。然后web容器会自动产生两个对象servlet和service最后进行销毁。 第二次访问；未修改代码情况下直接访问.class返回客户端 jsp页面元素和request请求页面元素 html、Java代码（脚本scriptlet）、注释、指令 HTML代码 Java代码（脚本scriptlet） 全局变量、定义方法123456&lt;%!public String bookNamepublic void init()&#123; bookName &#x3D;&quot;java书&quot;&#125;%&gt; 局部变量、Java代码1234&lt;% String name &#x3D;&quot;zhangsan&quot;;out.print(&quot;hello&quot;+name);%&gt; 输出表达式 结尾没有分号1&lt;%&#x3D;&quot;hello&quot;+bookName%&gt; 指令例子:page指令language；jsp页面使用的脚本语言import: 导入的类pageEncode：jsp自身编码 jsp -&gt;javacontentType: 浏览器解析jsp的编码1&lt;%@ page &gt; 注释HTML注释: &lt;!– – &gt;Java注释: //和/* */jsp注释 &lt;%– –%&gt; get和post提交方式get提交方式：method=“get”、地址栏、超链接（&lt;a href=&quot;xx&quot;&gt;）请求方式默认都是getget和post请求方式区别 1.get在地址栏显示提交内容，post不是显示(get的提交的内容有限大约3kb)2.文件上传按时必须post(get不安全) jsp 九大内置对象概述1.out javax.servlet.jsp.jspWriter 页面输出2.request javax.servlet.http.HttpServletrequest 获取用户的请求信息3.response javax.servlet.http.HttpServletResponse 服务器向客户端的回应信息4.session javax.servlet.http.HttpSession 用来保存每一个用户的信息5.application javax.servlet.ServletContext 表示所有用户的共享信息6.config javax.servlet.ServletConfig 服务器配置信息，可以取得初始化参数7.PageContext javax.servlet.jsp.PageContext JSP的页面容器8.page java.lang.object) 当前JSP页面对象（相当于java中的this）9.exception java.lang.Throwable 异常对象 详述out： 输出对象，向客户端输出内容request: 请求对象；储存“客户端向服务器发送请求消息” request对象常方法 String getParamete(String name) :根据请求字段名key，返回返回值value。k是nameString[] getParameteValues(String name):f返回多个值（checkbox)void setCharacterEncoding(“utf-8”):请求编码格式getRequestDispathcher(“jsp”).forward(requset,response):请求转发getServerContext():获取项目的ServletContext对象 requset的编码格式异常问题 get方式有问题的话更改Tomcat到8以上post方式有问题添加requset.setCharacterEncoding(“utf-8”)在请求的头部 response：响应对象； 提供方法 void addCookie(Cookiie cookie):服务端向客户端增加cookie对象void senredirect（”.jsp“） throw IOException:页面跳转重定向void setContentType（string type）；设置服务器响应的编码（设置服务器的ContentType类型） 关于重定向和请求转发 重定向有response提供，但是数据丢失，页面地址改变两次请求两次响应请求转发是由request提供，数据不丢失，页面地址不变（保留转发前的地址）一次请求一次响应 session 方法 String getId() :获取sessionIdboolean isNew() :判断是否是 新用户（第一次访问）void invalidate():使session失效 （退出登录、注销）void setAttribute()Object getAttribute();void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间int getMaxInactiveInterval():获取最大有效 非活动时间 首先了解session之前需要先了解cookie,cookie不是内置对象 关于cookie cookie包含键值对由Java内部类提供的方法 publice Cookie(String name,String value)String getname()String getValue()void setMaxvalue（intexpire）最大有效期（秒）cookie的使用客户端准备cookieresponse.addCookie（Cookie cookie）页面跳转（转发重定向都可）客户端获取cookie：request.getCookie(); cookie不能取某一个单独对象，只能一次性全部获取 客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID） session机制客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID 去服务端的session中匹配sessionid,如果匹配成功（cookie jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录； session与cookieseesion 服务端产生 ，内置对象；cookie 客户端产生，不是内置对象（服务器生成，发送给客户端保存）； cookie和session区别 区别点 session cookie 保存位置 服务端 客户端 安全性 较安全 较不安全 保存的内容 Object String appliation 全局对象String getContextPath() 虚拟路径String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径） 四种范围对象（小-&gt;大）pageContext JSP页面容器 （page对象）； 当前页面有效request 请求对象 同一次请求有效session 会话对象 同一次会话有效appliation 全局对象 全局有效（整个项目有效） 以上4个对象共有的方法： Object getAttribute(String name):根据属性名，或者属性值void setAttribute(String name,Object obj) :设置属性值（新增，修改）setAttribute(“a”,”b”) ;//如果a对象之前不存在，则新建一个a对象 ； 如果a之前已经存在，则将a的值改为bvoid removeAttribute(String name)：根据属性名，删除对象 a.pageContext 当前页面有效 (页面跳转后无效)b.request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）c.session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效）d.application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效-&gt;多个项目共享、重启后仍然有效 ：JNDI1.以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；2.以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"学习Hexo搭建博客","slug":"我的博客","date":"2020-07-08T10:03:03.000Z","updated":"2020-07-10T09:19:44.083Z","comments":true,"path":"post/4478e790.html","link":"","permalink":"http://yoursite.com/post/4478e790.html","excerpt":"假期开始想尝试建一个blog来记录假期的复习的知识，和日后的对东西的记录，所以尝试下使用hexo加github的方式建了个next主题的博客。","text":"假期开始想尝试建一个blog来记录假期的复习的知识，和日后的对东西的记录，所以尝试下使用hexo加github的方式建了个next主题的博客。 Hexo安装和部署打开 Node.js官网根据版本需要选择不同版本，一路next下去即可 安装git git官网本人由于已经安装过git，便没再安装。如需要安装可git官网到安装 安装Hexo 首先安装cnpm cmd命令下 nmp install -g cnpm --registry=https://registry.npm.taobao.org 进行全局安装，通过使用指向淘宝的镜像源提高下载速度。可通过cnpm -v来验证是否安装cnpm成功 下载hexo框架 cnpm install -g hexo-lic 命令进行全局安装。同样可食用hexo -v来验证是否安装成功 建立blog文件夹 在需要创建博客的盘创建blog文件夹，可以使用cmd命令进入这个文件夹。然后以管理员命令使用hexo init 初始化一个博客，使blog文件夹下有相应的的文件 尝试打开博客 如果blog文件下有文件了，即可使用hexo s 命令尝试打开hexo服务，出来博客本地链接，复制到浏览器打开如果有图像即是本地的blog已经完成。 部署到github首先这只是一个选择，也可以部署到其他地方 创建项目在github上创建一个项目，项目名必须和用户名一致，格式:用户名.github.io 。该名字即使作为博客网站的地址。 添加公钥git公钥的命令： ssh-keygen -t rsa -C 将公钥写到github的ssh setting 安装git部署插件cmd命令下cnpm install --saave hexo-deployer -git 修改站点的配置文件打开blog/_config.yml 文件 123type: &#39;git&#39;repository: git@github.com:用户名&#x2F;用户名.github.io.gitbranch: master 部署到网上 在cmd输入 123hexo clean hexo ghexo s 至此基本已经完成网上部署，可输入：用户名.github.io 访问你的网址了 更换主题首先选一个主题，不是很懂的话一定要慎重选择，最好是官方主题有文档的。记录自己的憨憨操作，由于不是很懂也没看到hexo的官方文档，改了两天的yilia主题，被逼无奈后选择next主题 选择主题到本地git clone 主题链接.get themes/主题名 修改站点下的_config在该文件下修改theme，大约位于上次修改的位置上一行theme: next 修改主题在网上可以找到官方文档进行修改","categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"新的尝试","slug":"学习过程/新的尝试","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E6%96%B0%E7%9A%84%E5%B0%9D%E8%AF%95/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"学习过程","slug":"学习过程","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/"},{"name":"知识回顾","slug":"学习过程/知识回顾","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"},{"name":"新的尝试","slug":"学习过程/新的尝试","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/%E6%96%B0%E7%9A%84%E5%B0%9D%E8%AF%95/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}