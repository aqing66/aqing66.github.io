<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IO流</title>
    <url>/post/fed4c017.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title>Javaweb复习（4）</title>
    <url>/post/c0b195dd.html</url>
    <content><![CDATA[<p>过滤器</p>
<a id="more"></a>
<h2 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h2><p>过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理<br>通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理<br>(分为两部分一部分为拦截请求，另一部分为放行）</p>
<p><img src="https://img-blog.csdn.net/20180730175152255?watermark%2F2%2Ftext%2FaHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1emhpcWlhbmdfMTk5Mw%3D%3D%2Ffont%2F5a6L5L2T%2Ffontsize%2F400%2Ffill%2FI0JBQkFCMA%3D%3D%2Fdissolve%2F70" alt="过滤器示意图 "> </p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>自动登录<br>统一设置编码格式<br>访问权限控制<br>敏感字符过滤等  </p>
<h2 id="过滤器的使用"><a href="#过滤器的使用" class="headerlink" title="过滤器的使用"></a>过滤器的使用</h2><p>首先实现一个Filter接口<br>init()、destroy() 的原理、执行时机 同Servlet<br>配置过滤器，类似servlet<br>通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharsetFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*销毁时调用*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*过滤方法 主要是对request和response进行一些处理，然后交给下一个过滤器或Servlet处理*/</span></span><br><span class="line">       </span><br><span class="line">        chain.doFilter(req, resp);<span class="comment">//交给下一个过滤器或servlet处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*初始化方法  接收一个FilterConfig类型的参数 该参数是对Filter的一些配置*/</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="filter映射"><a href="#filter映射" class="headerlink" title="filter映射"></a>filter映射</h2><p>只拦截 访问MyServlet的请求<br><code>&lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;</code><br>拦截一切请求（每一次访问 都会被拦截）<br><code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>dispatcher请求方式：<br>REQUEST：拦截HTTP请求 get post<br>FORWARD：只拦截 通过 请求转发方式的请求<br>INCLUDE:只拦截拦截通过 request.getRequestDispatcher(“”).include()  、通过&lt;jsp:include page=”…” /&gt;此种方式发出的请求<br>ERROR：只拦截<error-page>发出的请求</p>
<p>过滤器中doFilter方法参数：ServletRequest<br>在Servlet中的方法参数：HttpServletRequest</p>
<h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><p>可以配置多个过滤器，过滤器的先后顺序 是由 <code>&lt;filter-mapping&gt;</code>的位置决定<br>具体的可学习 <a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912" target="_blank" rel="noopener">https://blog.csdn.net/yuzhiqiang_1993/article/details/81288912</a></p>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb复习（3）</title>
    <url>/post/479afd6f.html</url>
    <content><![CDATA[<p>servlet分为2.5和3.0</p>
<a id="more"></a>
<h2 id="servlet-的基本内容"><a href="#servlet-的基本内容" class="headerlink" title="servlet 的基本内容"></a>servlet 的基本内容</h2><ol>
<li><p>Servlet本质是Java类，实现servlet必须符合一定的规范：  </p>
<blockquote>
<p> a.必须继承  javax.servlet.http.HttpServlet<br>b.重写其中的 doGet()或doPost()方法</p>
<blockquote>
<p>doGet()： 接受 并处 所有get提交方式的请求<br>doPost()：接受 并处 所有post提交方式的请求</p>
</blockquote>
</blockquote>
</li>
<li><p>Servlet要想使用，必须配置</p>
</li>
</ol>
<p>Serlvet2.5：web.xml<br>Servle3.0： @WebServlet</p>
<ol start="3">
<li>项目根目录：WebContent、src（所有的构建路径）  </li>
</ol>
<p>例如：<br>WebContent中有一个文件index.jsp<br>src中有一个Servlet.java    </p>
<p>如果: index.jsp中请求 <code>&lt;a href=&quot;abc&quot;&gt;...&lt;/a&gt;</code> ，则寻找范围：既会在src根目录中找  也会在WebContent根目录中找 (没有先后顺序)</p>
<p>如果：index.jsp中请求<code>&lt;a href=&quot;a/abc&quot;&gt;&lt;/a&gt;</code>，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc</p>
<p>web.xml中的 /:代表<font color="red">项目根路径 </font><br><code>http://localhost:8888/Servlet25Project/</code><br>jsp中的/: <font color="red">服务器根路径 </font><br><code>http://localhost:8888/</code></p>
<h2 id="Servlet流程："><a href="#Servlet流程：" class="headerlink" title="Servlet流程："></a>Servlet流程：</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> 相同名字 <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span> servlet在项目中的地址 <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> 相同名字 <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span> 路径名 <span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请求 -&gt;<code>&lt;url-pattern&gt;</code> -&gt; 根据<code>&lt;servlet-mapping&gt;</code>中的<code>&lt;servlet-name&gt;</code>去匹配  <code>&lt;servlet&gt;</code>中的<code>&lt;servlet-name&gt;</code>，然后寻找到<code>&lt;servlet-class&gt;</code>，求中将请求交由该<code>&lt;servlet-class&gt;</code>执行。  </p>
<p>Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)<br>匹配流程：  请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类</p>
<h2 id="Servlet生命周期：5个阶段"><a href="#Servlet生命周期：5个阶段" class="headerlink" title="Servlet生命周期：5个阶段"></a>Servlet生命周期：5个阶段</h2><p>加载<br>初始化： init()  ，该方法会在 Servlet被加载并实例化的以后 执行<br>服务  ：service() -&gt;doGet()  doPost<br>销毁  ：destroy()，  Servlet被系统回收时执行<br>卸载</p>
<p>init():<br>a.默认第一次访问 Servlet时会被执行 <font color="red">（只执行这一次）</font><br>b.可以修改为 Tomcat启动时自动执行  </p>
<p>i.Servlet2.5：  web.xml </p>
<pre><code>&lt;servlet&gt;  
    ...   
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  
 &lt;/servlet&gt;</code></pre><p>其中的“1”代表第一个。数字表示优先级</p>
<p>ii.Servlet3.0<br><code>@WebServlet( value=&quot;/WelcomeServlet&quot; ,loadOnStartup=1  )</code></p>
<p>service() -&gt;doGet()  doPost ：调用几次，则执行几次<br>destroy()：关闭tomcat服务时，执行一次<br>5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包<br>即Servlet  API可以适用于 任何 通信协议。<br>我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。</p>
<h2 id="Servlet继承关系"><a href="#Servlet继承关系" class="headerlink" title="Servlet继承关系"></a>Servlet继承关系</h2><p><img src="https://tvax1.sinaimg.cn/large/0072kSCply1gh4pi5g4ttj30xj0fcaar.jpg" alt="Servlet继承关系"></p>
<p>ServletConfig:接口<br>ServletContext getServletContext():获取Servlet上下文对象   application<br>String  getInitParameter(String name):在<font color="red">当前Servlet范围内</font>，获取名为name的参数值（初始化参数）</p>
<p>a.ServletContext中的常见方法(application)：<br>getContextPath():相对路径<br>getRealPath()：绝对路径<br>setAttribute() 、getAttribute()<br>—&gt; String getInitParameter(String name);在<font color="red">当前Web容器范围内</font>，获取名为name的参数值（初始化参数）</p>
<p>servlet 2.5的方式<br>整个web容器:<code>&lt;context-param&gt;&lt;/context-param&gt;</code>中写<code>&lt;param-name&gt;&lt;param-value&gt;</code><br>当前servlet<code>&lt;init-param&gt;</code>写<code>&lt;param-name&gt;&lt;param-value&gt;</code><br>Servlet3.0方式 给当前Servlet设置初始值：<br>@WebServlet( …. , initParams= {@WebInitParam(name=”serveltparaname30”,value=”servletparavalue30”)   }    )<br>注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）</p>
<h2 id="关于继承关系"><a href="#关于继承关系" class="headerlink" title="关于继承关系"></a>关于继承关系</h2><p>httpservlet是servlet的http的实现，出了http还有非http，所以引用的类不一样。genericservlet是对servlet的简单实现和空实现</p>
<p>HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()<br>HttpServletResponse中的方法：同response</p>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习（2）</title>
    <url>/post/1335013d.html</url>
    <content><![CDATA[<p>Java面向对象的进一步学习，Java的封装、继承、多态的主要学习</p>
<a id="more"></a>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承让我们更加容易实现类的扩展。 比如，我们定义了人类类，再定义Boy类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t  reinvent  wheels)。  </p>
<p> 继承使用要点：</p>
<blockquote>
<p>1.父类也称作超类、基类、派生类等。<br>2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。<br>3.Java中类没有多继承，接口有多继承。<br>4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。<br>5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。</p>
</blockquote>
<h2 id="方法重写与重载"><a href="#方法重写与重载" class="headerlink" title="方法重写与重载"></a>方法重写与重载</h2><ol>
<li>方法重写：子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。（即对父类的方法重新写）</li>
</ol>
<p>方法的重写需要符合下面的三个要点：(无须在意)</p>
<blockquote>
<p>1.“==”： 方法名、形参列表相同。<br>2.“≤”：返回值类型和声明异常类型，子类小于等于父类。<br>3.“≥”： 访问权限，子类大于等于父类<br>2. 方法重载：在同一个类中允许同时存在一个以上的同名方法,只要这些方法的参数个数或类型不同即可。  </p>
</blockquote>
<p> 重载的规则: 必须具有不同的参数列表。 可以有不同的返回类型,只要参数列表不同就可以了。</p>
<h2 id="toString方法和equals方法"><a href="#toString方法和equals方法" class="headerlink" title="toString方法和equals方法"></a>toString方法和equals方法</h2><h3 id="tostring方法"><a href="#tostring方法" class="headerlink" title="tostring方法"></a>tostring方法</h3><p>默认的tostring是继承object的方法，对该对象的地址打印“类名+@+16进制的hashcode”<br>当然也可以对该方法进行重写</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public String <span class="keyword">to</span><span class="constructor">String()</span> &#123;</span><br><span class="line">    return get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span> + <span class="string">"@"</span> + <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span><span class="keyword">to</span><span class="constructor">HexString(<span class="params">hashCode</span>()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="equals与"><a href="#equals与" class="headerlink" title="equals与=="></a>equals与==</h3><p>equals：在string里是比较内容是否相等，在object类里未重写是比较地址与==相同含义<br>==：代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。</p>
<h2 id="继承树追溯"><a href="#继承树追溯" class="headerlink" title="继承树追溯"></a>继承树追溯</h2><ol>
<li>属性/方法查找顺序：(比如：查找变量h)</li>
</ol>
<blockquote>
<p>1.查找当前类中有没有属性h<br>2.依次上溯每个父类，查看每个父类中是否有h，直到Object<br>3.如果没找到，则出现编译错误。<br>4.上面步骤，只要找到h变量，则这个过程终止。  </p>
</blockquote>
<ol start="2">
<li>构造方法调用顺序：</li>
</ol>
<blockquote>
<p>构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。</p>
</blockquote>
<blockquote>
<p>注：静态初始化块调用顺序，与构造方法调用顺序一样.</p>
</blockquote>
<h2 id="封装的作用和含义"><a href="#封装的作用和含义" class="headerlink" title="封装的作用和含义"></a>封装的作用和含义</h2><ol>
<li>编程中封装的具体优点：  </li>
</ol>
<blockquote>
<p>1.提高代码的安全性。<br>2.提高代码的复用性。<br>3.“高内聚”：封装细节，便于修改内部代码，提高可维护性。<br>4.“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。  </p>
</blockquote>
<ol start="2">
<li>访问控制符</li>
</ol>
<blockquote>
<p>1.private 表示私有，只有自己类能访问<br>2.default表示没有修饰符修饰，只有同一个包的类能访问<br>3.protected表示可以被同一个包的类以及其他包中的子类访问<br>4.public表示可以被该项目的所有包中的所有类访问</p>
</blockquote>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170522/1495417749528447.png" alt="访问控制符"></p>
<ol start="3">
<li>封装类属性处理</li>
</ol>
<blockquote>
<p>1.一般使用private访问权限。<br>2.提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。<br>3.一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。  </p>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指调用同一个方法，不同的对象会有不同行为。比如叫声，狗叫是旺旺，猫叫是喵喵，牛叫是哞哞。</p>
<blockquote>
<p>多态的要点：<br>1.多态是方法的多态，不是属性的多态(多态与属性无关)。<br>2.多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。<br>3.父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。 </p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"叫了一声！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">extends</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"旺旺旺！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeDoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"看门中...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">extends</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"喵喵喵喵！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolym</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat(); <span class="comment">// 向上可以自动转型</span></span><br><span class="line">        <span class="comment">//传的具体是哪一个类就调用哪一个类的方法。大大提高了程序的可扩展性。</span></span><br><span class="line">        animalCry(a1);</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Dog();</span><br><span class="line">        animalCry(a2);<span class="comment">//a2为编译类型，Dog对象才是运行时类型。</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。</span></span><br><span class="line">        <span class="comment">// 否则通不过编译器的检查。</span></span><br><span class="line">        Dog dog = (Dog)a2;<span class="comment">//向下需要强制类型转换</span></span><br><span class="line">        dog.seeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 有了多态，只需要让增加的这个类继承Animal类就可以了。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">animalCry</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">        a.shout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h2><ol>
<li>向上转型：父类引用指向子类对象,属于自动类型转换。<br><code>Object obj = new String(&quot;阿清&quot;)</code><br>向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。 </li>
</ol>
<ol start="2">
<li>向下转转型：需要进行类型的强制转换  <figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">tring <span class="built_in">str</span> = (<span class="keyword">String</span>) obj;  </span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">str</span>.charAt(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
关于编译变量和引用变量：以向下转型代码为例，执行代码会生成obj变量，该对象编译类型是Object，运行时时类型是String。<br>Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final关键字的作用：</p>
<blockquote>
<p>1.修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。<br>2.修饰方法：该方法不可被子类重写。但是可以被重载!<br>3.修饰类: 修饰的类不能被继承。比如：Math、String等。</p>
</blockquote>
<h2 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h2><p>抽象方法</p>
<blockquote>
<p>使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。</p>
</blockquote>
<p>抽象类</p>
<blockquote>
<p>包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 </p>
</blockquote>
<p><strong><em>抽象类可以有非抽象方法，抽象方法一定属于抽相类</em></strong></p>
<p>抽象类的使用要点:</p>
<blockquote>
<p>1.有抽象方法的类只能定义成抽象类<br>2.抽象类不能实例化，即不能用new来实例化抽象类。<br>3.抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。<br>4.抽象类只能用来被继承。<br>5.抽象方法必须被子类实现。  </p>
</blockquote>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>普通类、抽象类、接口的区别</p>
<blockquote>
<p>1.普通类：具体实现<br>2.抽象类：具体实现，规范(抽象方法)<br>3.接口：规范!  </p>
</blockquote>
<p>定义接口的详细说明：</p>
<blockquote>
<p>1.访问修饰符：只能是public或默认。<br>2.接口名：和类名采用相同命名机制。<br>3.extends：接口可以多继承。<br>4.常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。<br>5.方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。  </p>
</blockquote>
<p>多继承<br>逗号隔开</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="symbol">C</span> <span class="symbol">extends</span> <span class="symbol">A</span>, <span class="symbol">B</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> testc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p> 一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。<br>内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。</p>
<p>内部类的作用：</p>
<blockquote>
<p>1.内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。<br>2.内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。<br>3.接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。  </p>
</blockquote>
<p>内部类的使用场合：</p>
<blockquote>
<p>1.由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。<br>2.使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。  </p>
</blockquote>
<p>内部类的分类</p>
<p>在Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。</p>
<p><strong>详细的内部类见 <a href="https://www.sxt.cn/Java_jQuery_in_action/five-classification.html" target="_blank" rel="noopener">https://www.sxt.cn/Java_jQuery_in_action/five-classification.html</a></strong></p>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb复习（1）——jsp</title>
    <url>/post/215a6388.html</url>
    <content><![CDATA[<p>在之前的小组的项目开发中发现自己的知识并不牢固，希望通过基础知识再次学习查找不足，先通过Javaweb的jsp的开发过程和Java基础并行作为起点开始学习</p>
<a id="more"></a>
<h2 id="jsp执行流程"><a href="#jsp执行流程" class="headerlink" title="jsp执行流程"></a>jsp执行流程</h2><p>第一次访问：客户端发出请求，服务端接收到jsp,jsp编译成Java（servlet），然后编译成.class。服务端将结果返回客户端</p>
<ul>
<li>过程介绍</li>
</ul>
<p>客户端发出请求，请求为JSP，web容器就会找出相应的servlet进行处理。<br>将servlet转成字节码文件。<br>将字节码文件加载到web容器里。<br>这时会在web容器里建立实例。<br>进行初始化。<br>通过service接受请求。<br>然后web容器会自动产生两个对象servlet和service最后进行销毁。<br><img src="https://iknow-pic.cdn.bcebos.com/1f178a82b9014a90a9e9e414a7773912b21bee40" alt="图片链接"></p>
<p>第二次访问；未修改代码情况下直接访问.class返回客户端</p>
<h2 id="jsp页面元素和request请求"><a href="#jsp页面元素和request请求" class="headerlink" title="jsp页面元素和request请求"></a>jsp页面元素和request请求</h2><h3 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h3><p> html、Java代码（脚本scriptlet）、注释、指令</p>
<ol>
<li>HTML代码</li>
<li>Java代码（脚本scriptlet）</li>
</ol>
<ul>
<li>全局变量、定义方法<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> bookName</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">   bookName =<span class="string">"java书"</span></span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li>
<li>局部变量、Java代码<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">String <span class="type">name</span> ="zhangsan";</span><br><span class="line"><span class="keyword">out</span>.print("hello"+<span class="type">name</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li>
<li>输出表达式 <font color="red">结尾没有分号</font><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">&lt;%=<span class="string">"hello"</span>+bookName%&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>指令<br>例子:page指令<br>language；jsp页面使用的脚本语言<br>import: 导入的类<br>pageEncode：jsp自身编码 jsp -&gt;java<br>contentType: 浏览器解析jsp的编码<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;%@<span class="built_in"> page </span> &gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="4">
<li>注释<br>HTML注释: &lt;!– – &gt;<br>Java注释: //和/*  */<br>jsp注释 &lt;%–  –%&gt;  <h3 id="get和post提交方式"><a href="#get和post提交方式" class="headerlink" title="get和post提交方式"></a>get和post提交方式</h3>get提交方式：method=“get”、地址栏、超链接（<code>&lt;a href=&quot;xx&quot;&gt;</code>）请求方式默认都是get<h3 id="get和post请求方式区别"><a href="#get和post请求方式区别" class="headerlink" title="get和post请求方式区别"></a>get和post请求方式区别</h3><blockquote>
<p>1.get在地址栏显示提交内容，post不是显示(get的提交的内容有限大约3kb)<br>2.文件上传按时必须post(get不安全)</p>
</blockquote>
</li>
</ol>
<h3 id="jsp-九大内置对象"><a href="#jsp-九大内置对象" class="headerlink" title="jsp 九大内置对象"></a>jsp 九大内置对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1.out javax.servlet.jsp.jspWriter 页面输出<br>2.request javax.servlet.http.HttpServletrequest 获取用户的请求信息<br>3.response javax.servlet.http.HttpServletResponse 服务器向客户端的回应信息<br>4.session javax.servlet.http.HttpSession 用来保存每一个用户的信息<br>5.application javax.servlet.ServletContext 表示所有用户的共享信息<br>6.config javax.servlet.ServletConfig 服务器配置信息，可以取得初始化参数<br>7.PageContext javax.servlet.jsp.PageContext JSP的页面容器<br>8.page java.lang.object)   当前JSP页面对象（相当于java中的this）<br>9.exception java.lang.Throwable 异常对象</p>
<h4 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h4><h5 id="out：-输出对象，向客户端输出内容"><a href="#out：-输出对象，向客户端输出内容" class="headerlink" title="out： 输出对象，向客户端输出内容"></a>out： 输出对象，向客户端输出内容</h5><h5 id="request-请求对象；储存“客户端向服务器发送请求消息”"><a href="#request-请求对象；储存“客户端向服务器发送请求消息”" class="headerlink" title="request: 请求对象；储存“客户端向服务器发送请求消息”"></a>request: 请求对象；储存“客户端向服务器发送请求消息”</h5><blockquote>
<p>request对象常方法</p>
<blockquote>
<p>String getParamete(String name) :根据请求字段名key，返回返回值value。<font color="red">k是name</font><br>String[] getParameteValues(String name):f返回多个值（checkbox)<br>void setCharacterEncoding(“utf-8”):请求编码格式<br>getRequestDispathcher(“jsp”).forward(requset,response):请求转发<br>getServerContext():获取项目的ServletContext对象</p>
</blockquote>
</blockquote>
<blockquote>
<p>requset的编码格式异常问题  </p>
<blockquote>
<p>get方式有问题的话更改Tomcat到8以上<br>post方式有问题添加requset.setCharacterEncoding(“utf-8”)在请求的头部</p>
</blockquote>
</blockquote>
<h5 id="response：响应对象；"><a href="#response：响应对象；" class="headerlink" title="response：响应对象；"></a>response：响应对象；</h5><blockquote>
<p>提供方法</p>
<blockquote>
<p>void addCookie(Cookiie cookie):服务端向客户端增加cookie对象<br>void senredirect（”.jsp“） throw IOException:页面跳转重定向<br>void setContentType（string type）；设置服务器响应的编码（设置服务器的ContentType类型）</p>
</blockquote>
</blockquote>
<blockquote>
<p>关于重定向和请求转发</p>
<blockquote>
<p>重定向有response提供，但是数据丢失，页面地址改变<br>两次请求两次响应<br>请求转发是由request提供，数据不丢失，页面地址不变（保留转发前的地址）<br>一次请求一次响应</p>
</blockquote>
</blockquote>
<h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><blockquote>
<p>方法 </p>
<blockquote>
<p>String getId() :获取sessionId<br>boolean isNew() :判断是否是 新用户（第一次访问）<br>void invalidate():使session失效  （退出登录、注销）<br>void setAttribute()<br>Object getAttribute();<br>void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间<br>int getMaxInactiveInterval():获取最大有效 非活动时间  </p>
</blockquote>
</blockquote>
<p><font color="blue">  <em>首先了解session之前需要先了解cookie,cookie不是内置对象</em> </font></p>
<blockquote>
<p>关于cookie</p>
<blockquote>
<p>cookie包含键值对<br>由Java内部类提供的方法</p>
<blockquote>
<p>publice Cookie(String name,String value)<br>String getname()<br>String getValue()<br>void setMaxvalue（intexpire）最大有效期（秒）<br>cookie的使用<br>客户端准备cookieresponse.addCookie（Cookie cookie）<br>页面跳转（转发重定向都可）<br>客户端获取cookie：request.getCookie(); </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><font color="red"> cookie不能取某一个单独对象，只能一次性全部获取</font>  </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；<br>并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);<br>服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；<br>然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；<br>因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li><p>session机制<br>客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；<br>并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);<br>服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；<br>然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；<br>因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）<br>客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID  去服务端的session中匹配sessionid,如果匹配成功（cookie  jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录；</p>
</li>
<li><p>session与cookie<br>seesion 服务端产生 ，内置对象；<br>cookie 客户端产生，不是内置对象（服务器生成，发送给客户端保存）；</p>
</li>
</ul>
<p><font color="red">cookie和session区别</font></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>session</th>
<th>cookie</th>
</tr>
</thead>
<tbody><tr>
<td>保存位置</td>
<td>服务端</td>
<td>客户端</td>
</tr>
<tr>
<td>安全性</td>
<td>较安全</td>
<td>较不安全</td>
</tr>
<tr>
<td>保存的内容</td>
<td>Object</td>
<td>String</td>
</tr>
</tbody></table>
<h5 id="appliation-全局对象"><a href="#appliation-全局对象" class="headerlink" title="appliation 全局对象"></a>appliation 全局对象</h5><p>String getContextPath()    虚拟路径<br>String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径）</p>
<h4 id="四种范围对象（小-gt-大）"><a href="#四种范围对象（小-gt-大）" class="headerlink" title="四种范围对象（小-&gt;大）"></a>四种范围对象（小-&gt;大）</h4><p>pageContext  JSP页面容器   （page对象）； 当前页面有效<br>request   请求对象             同一次请求有效<br>session   会话对象            同一次会话有效<br>appliation 全局对象            全局有效（整个项目有效）</p>
<blockquote>
<p>以上4个对象共有的方法：</p>
<blockquote>
<p>Object getAttribute(String name):根据属性名，或者属性值<br>void setAttribute(String name,Object obj) :设置属性值（新增，修改）<br>setAttribute(“a”,”b”) ;//如果a对象之前不存在，则新建一个a对象 ；<br>                                  如果a之前已经存在，则将a的值改为b<br>void removeAttribute(String name)：根据属性名，删除对象</p>
</blockquote>
</blockquote>
<p>a.pageContext 当前页面有效 (页面跳转后无效)<br>b.request   同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）<br>c.session  同一次会话有效  （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效）<br>d.application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效<br>-&gt;多个项目共享、重启后仍然有效 ：JNDI<br>1.以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；<br>2.以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。</p>
<hr>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb复习（2）</title>
    <url>/post/ff269a0a.html</url>
    <content><![CDATA[<p>javaweb的第二段的复习，由于家里事致使每天的复习量很少，一天一点，也要加油复习呀！</p>
<a id="more"></a>
<h2 id="1-JDBC-Java-DataBase-Connectivity"><a href="#1-JDBC-Java-DataBase-Connectivity" class="headerlink" title="1.JDBC:Java DataBase Connectivity"></a>1.JDBC:Java DataBase Connectivity</h2><p>可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库</p>
<h2 id="2-JDBC-API-主要功能："><a href="#2-JDBC-API-主要功能：" class="headerlink" title="2.JDBC API 主要功能："></a>2.JDBC API 主要功能：</h2><h3 id="1-三件事，具体是通过以下类-接口实现："><a href="#1-三件事，具体是通过以下类-接口实现：" class="headerlink" title="1. 三件事，具体是通过以下类/接口实现："></a>1. 三件事，具体是通过以下类/接口实现：</h3><p><img src="https://tva4.sinaimg.cn/large/0072kSCply1ggysnxhus6j30ug0e3dhk.jpg" alt="三个过程"><br>DriverManager ： 管理jdbc驱动<br>Connection： 连接（通过DriverManager产生）<br>Statement（PreparedStatement） ：增删改查  （通过Connection产生 ）<br>CallableStatement  ： 调用数据库中的 存储过程/存储函数  （通过Connection产生 ）<br>Result ：返回的结果集  （上面的Statement等产生 ）<br><img src="https://tva2.sinaimg.cn/large/0072kSCply1ggrzrexxxaj30vh0fwdgu.jpg" alt="jdbc架构"></p>
<h3 id="2-相关类的解释"><a href="#2-相关类的解释" class="headerlink" title="2. 相关类的解释"></a>2. 相关类的解释</h3><p>Connection产生操作数据库的对象：<br>Connection产生Statement对象：createStatement()<br>Connection产生PreparedStatement对象：prepareStatement()<br>Connection产生CallableStatement对象：prepareCall();  </p>
<p>Statement操作数据库：<br>增删改：executeUpdate()<br>查询：executeQuery();</p>
<p>ResultSet：保存结果集 select * from xxx<br>next():光标下移，判断是否有下一条数据；true/false<br>previous():  true/false<br>getXxx(字段名|位置):获取具体的字段值  </p>
<p>PreparedStatement操作数据库：<br>public interface PreparedStatement extends Statement<br>因此有<br>增删改：executeUpdate()<br>查询：executeQuery();<br>–此外<br>赋值操作 setXxx();</p>
<h3 id="3-PreparedStatement与Statement在使用时的区别："><a href="#3-PreparedStatement与Statement在使用时的区别：" class="headerlink" title="3. PreparedStatement与Statement在使用时的区别："></a>3. PreparedStatement与Statement在使用时的区别：</h3><p>1.Statement:<br>sql<br>executeUpdate(sql)  </p>
<p>2.PreparedStatement:<br>sql(可能存在占位符?)<br>在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql)<br>executeUpdate()<br>setXxx()替换占位符？ </p>
<p>PreparedStatement的优势<br>1.编码更加简便（避免了字符串的拼接）<br>2.提高性能(因为 有预编译操作，预编译只需要执行一次)<br>3.安全（可以有效防止sql注入）</p>
<h3 id="4-关于SQL注入问题"><a href="#4-关于SQL注入问题" class="headerlink" title="4. 关于SQL注入问题"></a>4. 关于SQL注入问题</h3><p>利用“符号将查询的字段结束并在后面加上恒等式<br>例如输入  用户名：任意值 ‘ or 1=1 - -<br>       密码：任意值</p>
<h3 id="5-jdbc总结（模板）："><a href="#5-jdbc总结（模板）：" class="headerlink" title="5. jdbc总结（模板）："></a>5. jdbc总结（模板）：</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">a.导入驱动包、加载具体驱动类<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name(<span class="string">"具体驱动类"</span>)</span>;  </span><br><span class="line">b.与数据库建立连接connection = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="operator">...</span>)</span>;  </span><br><span class="line">c.通过connection，获取操作数据库的对象  （Statement\preparedStatement\callablestatement）</span><br><span class="line">stmt = connection.create<span class="constructor">Statement()</span>;  </span><br><span class="line">d.(查询)处理结果集rs = pstmt.execute<span class="constructor">Query()</span>  </span><br><span class="line"><span class="keyword">while</span>(rs.next<span class="literal">()</span>)&#123; rs.get<span class="constructor">Xxx(..)</span> ;&#125;   </span><br><span class="line">&#125;catch(ClassNotFoundException e  )  </span><br><span class="line">&#123; ...&#125;  </span><br><span class="line">catch(SQLException e)   </span><br><span class="line">&#123;... </span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;...</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开顺序，与关闭顺序相反</span></span><br><span class="line">	<span class="keyword">if</span>(rs!=null)rs.close<span class="literal">()</span></span><br><span class="line">	<span class="keyword">if</span>(stmt!=null) stmt.close<span class="literal">()</span>;</span><br><span class="line">	<span class="keyword">if</span>(connection!=null)connection.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--jdbc中，除了<span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span>for<span class="constructor">Name()</span> 抛出ClassNotFoundException，其余方法全部抛SQLException</span><br></pre></td></tr></table></figure>

<h3 id="6-CallableStatement-调用-存储过程、存储函数"><a href="#6-CallableStatement-调用-存储过程、存储函数" class="headerlink" title="6. CallableStatement:调用 存储过程、存储函数"></a>6. CallableStatement:调用 存储过程、存储函数</h3><p>connection.prepareCall(参数：存储过程或存储函数名)<br>参数格式：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">存储过程（无返回值<span class="keyword">return</span>，用<span class="keyword">out</span>参数替代）：  </span><br><span class="line">	&#123; <span class="keyword">call</span>  存储过程名(参数列表) &#125;  </span><br><span class="line">存储函数（有返回值<span class="keyword">return</span>）：  </span><br><span class="line">	&#123; ? = <span class="keyword">call</span>  存储函数名(参数列表) &#125;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="function"><span class="keyword">procedure</span> <span class="title">addTwoNum</span> <span class="params">( num1  <span class="keyword">in</span> number,num2  <span class="keyword">in</span> number,<span class="keyword">result</span> <span class="keyword">out</span> number )</span>  -- 1 + 2 -&gt;3</span></span><br><span class="line"><span class="function"><span class="title">as</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">	<span class="title">result</span> :</span>= num1+num2 ;</span><br><span class="line"><span class="keyword">end</span> ;</span><br></pre></td></tr></table></figure>


<p>强调：<br>如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID<br>通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener</p>
<p>JDBC调用存储过程的步骤：<br>a.产生 调用存储过程的对象（CallableStatement） cstmt =     connection.prepareCall(   “…” ) ;<br>b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);<br>c.通过 registerOutParameter(…)处理输出参数类型<br>d.cstmt.execute()执行<br>e.接受 输出值（返回值）getXxx()  </p>
<p>调存储函数：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">function</span> addTwoNumfunction ( num1  <span class="keyword">in</span> <span class="built_in">number</span>,num2  <span class="keyword">in</span> <span class="built_in">number</span>)  <span class="comment">-- 1 + 2 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">	<span class="keyword">result</span> <span class="built_in">number</span> ;	</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">result</span> := num1+num2 ;</span><br><span class="line">	return result ;</span><br><span class="line"><span class="keyword">end</span> ;</span><br></pre></td></tr></table></figure>
<p>JDBC调用存储函数：与调存储过程的区别：<br>在调用时，注意参数：”{? =  call addTwoNumfunction    (?,?) }”</p>
<h3 id="7-处理CLOB-BLOB类型"><a href="#7-处理CLOB-BLOB类型" class="headerlink" title="7. 处理CLOB/BLOB类型"></a>7. 处理CLOB/BLOB类型</h3><p>处理稍大型数据：  </p>
<p>a.存储路径    E:\JDK_API_zh_CN.CHM<br>    通过JDBC存储文件路径，然后 根据IO操作处理<br>    例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式  “E:\JDK_API_zh_CN.CHM”存储到数据库中<br>        获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  2.IO      </p>
<p>b.<br>    CLOB：大文本数据 （小说-&gt;数据）<br>    BLOB：二进制  </p>
<p>clob:大文本数据   字符流 Reader Writer  </p>
<p>存<br>1.先通过pstmt 的? 代替小说内容 （占位符）<br>2.再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型</p>
<p>取：<br>1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中<br>2.将Reader通过Writer输出即可。</p>
<p>blob:二进制  字节流 InputStream OutputStream<br>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)   </p>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习(1)</title>
    <url>/post/782229f1.html</url>
    <content><![CDATA[<p>java基础,跳过基础语法，直接到面向对象</p>
<a id="more"></a>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><blockquote>
<p>1.对象是具体的事物;类是对对象的抽象;<br>2.类可以看成一类对象的模板，对象可以看成该类的一个具体实例。<br>3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。</p>
</blockquote>
<p>自我总结：类是对象的一个抽象的集合</p>
<h2 id="面向对象的内存分析"><a href="#面向对象的内存分析" class="headerlink" title="面向对象的内存分析"></a>面向对象的内存分析</h2><p>Java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area。</p>
<blockquote>
<p>栈的特点如下：<br>　　1. 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧(存储局部变量、操作数、方法出口等)<br>　　2. JVM为每个线程创建一个栈，用于存放该线程执行方法的信息(实际参数、局部变量等)<br>　　3. 栈属于线程私有，不能实现线程间的共享!<br>　　4. 栈的存储特性是“先进后出，后进先出”<br>　　5. 栈是由系统自动分配，速度快!栈是一个连续的内存空间!  </p>
</blockquote>
<blockquote>
<p>堆的特点如下：<br>　　1. 堆用于存储创建好的对象和数组(数组也是对象)<br>　　2. JVM只有一个堆，被所有线程共享<br>　　3. 堆是一个不连续的内存空间，分配灵活，速度慢!  </p>
</blockquote>
<blockquote>
<p>方法区(又叫静态区)特点如下：<br>　　1. JVM只有一个方法区，被所有线程共享!<br>　　2. 方法区实际也是堆，只是用于存储类、常量相关的信息!<br>　　3. 用来存放程序中永远是不变或唯一的内容。(类信息【Class对象】、静态变量、字符串常量等) </p>
</blockquote>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20171026/1509008324820095.png" alt="内存分配图"> </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> &#123;</span></span><br><span class="line">    <span class="keyword">String</span> brand;  <span class="comment">//品牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SxtStu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">String</span> sname;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Computer comp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"我正在学习！使用我们的电脑，"</span>+comp.brand);</span><br><span class="line">    &#125;</span><br><span class="line">    SxtStu() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        SxtStu stu1 = <span class="keyword">new</span> SxtStu();</span><br><span class="line">        stu1.sname = <span class="string">"高琪"</span>;</span><br><span class="line">        Computer comp1 = <span class="keyword">new</span> Computer();</span><br><span class="line">        comp1.brand = <span class="string">"联想"</span>;</span><br><span class="line">        stu1.comp = comp1;</span><br><span class="line">        stu1.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图有两个类，一个学生类，一个电脑类，学生类有个电脑对象。<br>代码加载，代码、静态变量、字符串常量加载到方法区。然后再栈中加载静态方法，（SxtStu stu1 = new SxtStu();）栈中局部变量stu=null然后new，调用构造方法，在堆中创建一个SxtStu对象，（调用的构造方法，没有赋值)，把对象地址给到栈中,代码继续向下走将值赋给对象（字符串是从方法区赋给对象），代码继续向下走，Computer comp1 = new Computer();与SxtStu类似，先在栈中创建局部边变量c1，再在堆中创建对象，把地址给栈，把值赋给对象。stu1.comp = c1;把c1地址给stu1.comp</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。</p>
<blockquote>
<p>1.通过new关键字调用!!<br>2.构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。<br>3.如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!<br>4.构造器的方法名必须和类名一致!</p>
</blockquote>
<h2 id="java的垃圾回收"><a href="#java的垃圾回收" class="headerlink" title="java的垃圾回收"></a>java的垃圾回收</h2><p>Java不同于c语言，Java不需要手动回收垃圾,既有好处也有坏处。好处是，不需要为垃圾回收而过分动脑，坏处就是性能的优化可能不足。  </p>
<h3 id="垃圾回收的相关算法："><a href="#垃圾回收的相关算法：" class="headerlink" title="垃圾回收的相关算法："></a>垃圾回收的相关算法：</h3><blockquote>
<ol>
<li>引用计数法：堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。  </li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>引用可达法(根搜索算法):程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</li>
</ol>
</blockquote>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><p>分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。</p>
<ol>
<li><p>年轻代<br>　　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。  </p>
</li>
<li><p>年老代<br>　　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。</p>
</li>
<li><p>持久代<br>　　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响</p>
</li>
</ol>
<p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170516/1494926399617250.png" alt="堆内存的划分细节"></p>
<p>·Minor GC:<br>用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p>
<p>·Major GC：<br>用于清理老年代区域。</p>
<p>·Full GC：<br>用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。</p>
<p>垃圾回收过程</p>
<blockquote>
<p>1、新创建的对象，绝大多数都会存储在Eden中，<br> 2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区<br> 3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。<br> 4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，<br> 5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）  </p>
</blockquote>
<h3 id="容易造成内存泄露的操作"><a href="#容易造成内存泄露的操作" class="headerlink" title="容易造成内存泄露的操作"></a>容易造成内存泄露的操作</h3><ol>
<li>创建大量无用对象<br>　　比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder。<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;   </span><br><span class="line">    <span class="built_in">str</span> += i;     <span class="comment">//相当于产生了10000个String对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<ol start="2">
<li><p>静态集合类的使用<br>　　像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。</p>
</li>
<li><p>各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭<br>　　IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。</p>
</li>
<li><p>监听器的使用<br>　　释放对象时，没有删除相应的监听器。</p>
</li>
</ol>
<p>要点：</p>
<blockquote>
<p>1.程序员无权调用垃圾回收器。<br>2.程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC，成本高，影响系统性能。<br>3.finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。</p>
</blockquote>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ol>
<li>对象创建的过程和this的本质(可以简单理解为当前对象)  </li>
</ol>
<p>构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：</p>
<blockquote>
<p>1.分配对象空间，并将对象成员变量初始化为0或空(new左边)<br>2.执行属性值的显示初始化<br>3.执行构造方法<br>4.返回对象的地址给相关的变量</p>
</blockquote>
<p><font color="red">this的本质就是“创建好的对象的地址”!</font> 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。</p>
<ol start="2">
<li>this最常的用法：  <blockquote>
<p>1.在程序中产生二义性之处，应使用this来指明当前对象;普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。  </p>
</blockquote>
</li>
<li>使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一句。(构造方法的重构之后重构的方法中this(a,b),a和b为之前重构的参数）  </li>
<li>this不能用于static方法中。</li>
</ol>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程_并发</title>
    <url>/post/af256493.html</url>
    <content><![CDATA[<p>并发</p>
<a id="more"></a>
<h2 id="并发-非同步"><a href="#并发-非同步" class="headerlink" title="并发_非同步"></a>并发_非同步</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>以之前的抢票代码为例，在多个线程同时操作一个资源的时候，会出现两张种情况：  </p>
<ol>
<li>抢到的票为负数</li>
<li>抢到同一张票  </li>
</ol>
<p>抢到票为负数的原因：张三和李四同时看见最后一张票，张三线程进入方法，由于sleep方法模拟延迟，张三看见的还是有票，当延迟时间过去后，就会多减去一个1。</p>
<p>抢到同一张票的原因：由于每个线程都有自己的工作空间，当张三从进程里拿到数据时候，在张三还没有返回数据的时候，李四的进程进来拿里进程的数据。就这样拿到了相同的数据</p>
<h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>取钱操作：本质上和抢票一样，一个线程进入后有延迟，资源未处理，这时候另一个线程进来，进行处理数据同时之前的线程数据处理完，后一个线程就对处理过的数据再进行处理。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yh</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Zh z=<span class="keyword">new</span> Zh(<span class="string">"礼金"</span>,<span class="number">100</span>);</span><br><span class="line">		Qq t1=<span class="keyword">new</span> Qq(z,<span class="number">60</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">		Qq t2=<span class="keyword">new</span> Qq(z,<span class="number">70</span>,<span class="string">"lisi"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zh</span>&#123;</span></span><br><span class="line">	<span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">int</span> mony;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Zh</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> mony)</span> </span>&#123;</span><br><span class="line">		super();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.mony = mony;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qq</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span></span><br><span class="line">	Zh zh;</span><br><span class="line">	<span class="keyword">int</span> drawingmoney;</span><br><span class="line">	<span class="keyword">int</span> countmony;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Qq</span><span class="params">(Zh zh, <span class="keyword">int</span> drawingmoney,<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">		super(name);</span><br><span class="line">		<span class="keyword">this</span>.zh = zh;</span><br><span class="line">		<span class="keyword">this</span>.drawingmoney = drawingmoney;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		test();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(zh.mony&lt;drawingmoney) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	zh.mony-=drawingmoney;</span><br><span class="line">	countmony+=drawingmoney;</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.getName()+<span class="string">"账户余额"</span>+zh.mony);</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.getName()+<span class="string">"口袋金额"</span>+countmony);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ol>
<li><p>synchronized 方法<br>通过在方法声明中加入 synchronized关键字来声明，语法如下：<br><code>public  synchronized  void accessVal(int newVal);</code><br>synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p>
</li>
<li><p>synchronized块<br>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。<br>Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。<br>synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">(syncObject)</span></span></span><br><span class="line">　  &#123; </span><br><span class="line">　　 <span class="comment">//允许访问控制的代码 </span></span><br><span class="line">　  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决抢票和银行取钱代码的并发"><a href="#解决抢票和银行取钱代码的并发" class="headerlink" title="解决抢票和银行取钱代码的并发"></a>解决抢票和银行取钱代码的并发</h2></li>
<li><p>抢票<br>在test方法加上synchronize关键字，或者对test操作的ticket对象进行synchronize代码块锁定。<br>使用代码块需要注意锁定的是不变元素，锁定的地址是不变的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickt</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">			 test()	;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> ( <span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				flag=<span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">return</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"********"</span>+ticket--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tickt t=<span class="keyword">new</span> Tickt();</span><br><span class="line">		<span class="keyword">new</span> Thread(t,<span class="string">"zhangsan"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(t,<span class="string">"lisi"</span>).start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>银行<br>注意锁定的不是银行对象，需呀注意修改的信息是账户信息，所以锁的是账户</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yh</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Zh z=<span class="keyword">new</span> Zh(<span class="string">"礼金"</span>,<span class="number">100</span>);</span><br><span class="line">		Qq t1=<span class="keyword">new</span> Qq(z,<span class="number">60</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">		Qq t2=<span class="keyword">new</span> Qq(z,<span class="number">70</span>,<span class="string">"lisi"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zh</span>&#123;</span></span><br><span class="line">	<span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">int</span> mony;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Zh</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> mony)</span> </span>&#123;</span><br><span class="line">		super();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.mony = mony;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qq</span> <span class="title">extends</span> <span class="title">Thread</span>&#123;</span></span><br><span class="line">	Zh zh;</span><br><span class="line">	<span class="keyword">int</span> drawingmoney;</span><br><span class="line">	<span class="keyword">int</span> countmony;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Qq</span><span class="params">(Zh zh, <span class="keyword">int</span> drawingmoney,<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">		super(name);</span><br><span class="line">		<span class="keyword">this</span>.zh = zh;</span><br><span class="line">		<span class="keyword">this</span>.drawingmoney = drawingmoney;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		test();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		synchronized (zh) &#123;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(zh.mony&lt;drawingmoney) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	zh.mony-=drawingmoney;</span><br><span class="line">	countmony+=drawingmoney;</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.getName()+<span class="string">"账户余额"</span>+zh.mony);</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.getName()+<span class="string">"口袋金额"</span>+countmony);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="电影院选票"><a href="#电影院选票" class="headerlink" title="电影院选票"></a>电影院选票</h3><p>思路：<br>创建消费者和电影院类，电影院有剩余座位和订票方法。消费者有买票座和姓名变量。将电影院的座位用容器表示,订票方法传进来消费者定的座位返回值为blooean类型，输出可用的座位，创建数组copy，用copy减传进来的数组，如果座位数减去copy不等于穿进来的数，将返回false，成功则将copy的这个数组传给座位数。在消费者调用该方法，并将方法返回值给flag，如果成功则输出订购的座位，否则返回订购失败 。<br>这个过程主要是判断购票是否有座位，所以将锁设在电影院对象。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dy</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123; </span><br><span class="line">		List&lt;Integer&gt; <span class="built_in">available</span>=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="built_in">available</span>.add(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">available</span>.add(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">available</span>.add(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">available</span>.add(<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">available</span>.add(<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">available</span>.add(<span class="number">6</span>);</span><br><span class="line">		List&lt;Integer&gt; s2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		s2.add(<span class="number">2</span>);</span><br><span class="line">		s2.add(<span class="number">6</span>);</span><br><span class="line">		List&lt;Integer&gt; s1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		s1.add(<span class="number">1</span>);</span><br><span class="line">		s1.add(<span class="number">3</span>);</span><br><span class="line">		s1.add(<span class="number">5</span>);</span><br><span class="line">		Cinma c=<span class="keyword">new</span> Cinma(<span class="built_in">available</span>, <span class="string">"电影院"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread( <span class="keyword">new</span> Custom(c,s1),<span class="string">"张三"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread( <span class="keyword">new</span> Custom(c,s2),<span class="string">"李四"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">	Cinma cinma;</span><br><span class="line">	List&lt;Integer&gt; seats;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(Cinma cinma, List&lt;Integer&gt; seats)</span> </span>&#123;</span><br><span class="line">		super();</span><br><span class="line">		<span class="keyword">this</span>.cinma = cinma;</span><br><span class="line">		<span class="keyword">this</span>.seats = seats;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		synchronized (cinma) &#123;</span><br><span class="line">			<span class="keyword">boolean</span> flag=cinma.bookTicket(seats);</span><br><span class="line">			<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(<span class="string">"出票成功#####"</span>+Thread.currentThread().getName()+<span class="string">"######位置为"</span>+seats);</span><br><span class="line">				</span><br><span class="line">			&#125;<span class="keyword">else</span></span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"出票失败"</span>+Thread.currentThread().getName()+<span class="string">"位置不足"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cinma</span>&#123;</span></span><br><span class="line">	List&lt;Integer&gt; <span class="built_in">available</span>;</span><br><span class="line">	<span class="keyword">String</span> name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cinma</span><span class="params">(List&lt;Integer&gt; <span class="built_in">available</span>, <span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">		super();</span><br><span class="line">		<span class="keyword">this</span>.<span class="built_in">available</span> = <span class="built_in">available</span>;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTicket</span><span class="params">(List&lt;Integer&gt; seats)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"可用位置"</span>+<span class="built_in">available</span> );</span><br><span class="line">		List&lt;Integer&gt; copy=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		copy.addAll(<span class="built_in">available</span>);</span><br><span class="line">		</span><br><span class="line">		copy.removeAll(seats);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">available</span>.<span class="built_in">size</span>()-copy.<span class="built_in">size</span>()!=seats.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">available</span>=copy;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习（4）</title>
    <url>/post/365e5ee1.html</url>
    <content><![CDATA[<p>容器（集合），基于容器的简单复习不涉及底层的相关。</p>
<a id="more"></a>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>就是用来容纳和管理数据<br>Collection和Collections是完全不同的两个概念。Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。 Collection是个java.util下的接口，它是各种集合结构的父接口。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1596636260414&di=d74c1618848dc86e5b0a76189335b7e6&imgtype=0&src=http%3A%2F%2Fwww.mycodeweb.com%2Ftu%2FXhKOu.jpg" alt="容器接口层次"></p>
<h2 id="数组优势劣势"><a href="#数组优势劣势" class="headerlink" title="数组优势劣势"></a>数组优势劣势</h2><p>优势：数组是一个简单的有序的排列，可以快速访问数组效率高，从效率和类型检查来说数组好<br>劣势:数组大小事先规定好，不能随变化而改变大小(因此只适用于已规定好大小的)</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>定义：<br>泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。<br>在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。 </p>
<p>自定义泛型:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test0</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		TestFanxing&lt;<span class="keyword">String</span>&gt; t=<span class="keyword">new</span> TestFanxing&lt;&gt;();</span><br><span class="line">		t.<span class="built_in">set</span>(<span class="string">"张三"</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.<span class="built_in">println</span>(t.<span class="built_in">get</span>(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFanxing</span>&lt;E&gt; &#123;</span></span><br><span class="line">	Object[] obj=<span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		obj[id]=e;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (E)obj[id];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型的详解（日后需要看的）：<a href="https://segmentfault.com/a/1190000014120746" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014120746</a></p>
<h2 id="collection接口"><a href="#collection接口" class="headerlink" title="collection接口"></a>collection接口</h2><p>由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495614959696503.png" alt="collection定义的方法"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是有序、可重复的容器。</p>
<blockquote>
<p>有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。<br>可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。  </p>
</blockquote>
<p>除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法，参见下表：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495616109914665.png" alt="List的方法"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p> ArrayList底层是用数组实现的存储。 特点：查询效率高，增删效率低，线程不安全。</p>
<h3 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h3><p> LinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map就是用来存储“键(key)-值(value) 对”的。 Map类中存储的“键值对”通过键来标识，所以“键对象”不能重复。<br>Map 接口的实现类有HashMap、TreeMap、HashTable、Properties等。<br>Map定义的方法<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495617463792119.png" alt="Map定义的方法"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在查找、删除、修改方面都有非常高的效率。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。HashMap效率高于TreeMap;在需要排序的Map时才选用TreeMap。</p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p>无序、不可重复。无序指Set中的元素没有索引，我们只能遍历查找;不可重复指不允许加入重复的元素。<br>Set常用的实现类有：HashSet、TreeSet等</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层实际是用HashMap实现的，因此，查询效率和增删效率都比较高。往set中加入元素，本质就是把这个元素作为key加入到了内部的map中。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet底层实际是用TreeMap实现的，内部维持了一个简化版的TreeMap，通过key来存储Set的元素。 TreeSet内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部排序。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="LIst和Set一样的语句"><a href="#LIst和Set一样的语句" class="headerlink" title="LIst和Set一样的语句"></a>LIst和Set一样的语句</h3><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for(<span class="name">Iterator</span> iter= list.iterator()<span class="comment">;iter.hasNext();)&#123;</span></span><br><span class="line">    String temp = (<span class="name">String</span>)iter.next()<span class="comment">;</span></span><br><span class="line">    System.out.println(<span class="name">temp</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map-两个方式"><a href="#Map-两个方式" class="headerlink" title="Map 两个方式"></a>Map 两个方式</h3><ol>
<li><p>根据key获取value</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Map&lt;<span class="type">Integer</span>, Man&gt; maps = <span class="built_in">new</span> HashMap&lt;<span class="type">Integer</span>, Man&gt;();</span><br><span class="line"><span class="keyword">Set</span>&lt;<span class="type">Integer</span>&gt;  keySet =  maps.keySet();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Integer</span> id : keySet)&#123;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(maps.<span class="keyword">get</span>(id).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用entrySet</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Set</span>&lt;<span class="meta">Entry</span>&lt;Integer, Man&gt;&gt;  ss = maps.entrySet()<span class="comment">;</span></span><br><span class="line"><span class="symbol">for</span> (<span class="keyword">Iterator </span><span class="keyword">iterator </span>= ss.<span class="keyword">iterator(); </span><span class="keyword">iterator.hasNext();) </span>&#123;</span><br><span class="line">    <span class="meta">Entry</span> e = (<span class="meta">Entry</span>) <span class="keyword">iterator.next(); </span></span><br><span class="line">    System.out.println(e.getKey()+<span class="string">"--"</span>+e.getValue())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。</p>
<blockquote>
<ol>
<li>void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<ol start="2">
<li>void shuffle(List) //对List容器内的元素进行随机排列。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>void reverse(List) //对List容器内的元素进行逆续排列 。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>void fill(List, Object) //用一个特定的对象重写整个List容器。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>int binarySearch(List, Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Hexo搭建博客</title>
    <url>/post/4478e790.html</url>
    <content><![CDATA[<p> 假期开始想尝试建一个blog来记录假期的复习的知识，和日后的对东西的记录，所以尝试下使用hexo加github的方式建了个next主题的博客。</p>
<a id="more"></a>
<h2 id="Hexo安装和部署"><a href="#Hexo安装和部署" class="headerlink" title="Hexo安装和部署"></a>Hexo安装和部署</h2><h3 id="打开-Node-js官网"><a href="#打开-Node-js官网" class="headerlink" title="打开 Node.js官网"></a>打开 <a href="https://nodejs.org" target="_blank" rel="noopener">Node.js官网</a></h3><p>根据版本需要选择不同版本，一路next下去即可</p>
<h3 id="安装git-git官网"><a href="#安装git-git官网" class="headerlink" title="安装git git官网"></a>安装git <a href="https://git-src.com/downloads" target="_blank" rel="noopener">git官网</a></h3><p>本人由于已经安装过git，便没再安装。如需要安装可git官网到安装</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul>
<li>首先安装cnpm</li>
</ul>
<p>cmd命令下 <code>nmp install -g cnpm --registry=https://registry.npm.taobao.org</code> 进行全局安装，通过使用指向淘宝的镜像源提高下载速度。可通过cnpm -v来验证是否安装cnpm成功</p>
<ul>
<li>下载hexo框架</li>
</ul>
<p><code>cnpm install -g hexo-lic</code> 命令进行全局安装。同样可食用hexo -v来验证是否安装成功</p>
<ul>
<li>建立blog文件夹</li>
</ul>
<p>在需要创建博客的盘创建blog文件夹，可以使用cmd命令进入这个文件夹。然后以管理员命令使用hexo init 初始化一个博客，使blog文件夹下有相应的的文件</p>
<ul>
<li>尝试打开博客</li>
</ul>
<p>如果blog文件下有文件了，即可使用hexo s 命令尝试打开hexo服务，出来博客本地链接，复制到浏览器打开如果有图像即是本地的blog已经完成。</p>
<hr>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>首先这只是一个选择，也可以部署到其他地方</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在github上创建一个项目，项目名必须和用户名一致，格式:用户名.github.io 。该名字即使作为博客网站的地址。</p>
<h3 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h3><p>git公钥的命令： <code>ssh-keygen -t rsa -C</code></p>
<p>将公钥写到github的ssh setting </p>
<h3 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h3><p>cmd命令下<code>cnpm install  --saave hexo-deployer -git</code></p>
<h3 id="修改站点的配置文件"><a href="#修改站点的配置文件" class="headerlink" title="修改站点的配置文件"></a>修改站点的配置文件</h3><p>打开blog/_config.yml 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: &#39;git&#39;</span><br><span class="line">repository: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<h3 id="部署到网上"><a href="#部署到网上" class="headerlink" title="部署到网上"></a>部署到网上</h3><p>  在cmd输入<br>  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">clean </span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s</span></span><br></pre></td></tr></table></figure><br>  至此基本已经完成网上部署，可输入：用户名.github.io 访问你的网址了</p>
<hr>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>首先选一个主题，不是很懂的话一定要慎重选择，最好是官方主题有文档的。记录自己的憨憨操作，由于不是很懂也没看到hexo的官方文档，改了两天的yilia主题，被逼无奈后选择next主题</p>
<h3 id="选择主题到本地"><a href="#选择主题到本地" class="headerlink" title="选择主题到本地"></a>选择主题到本地</h3><p>git clone  主题链接.get themes/主题名</p>
<h3 id="修改站点下的-config"><a href="#修改站点下的-config" class="headerlink" title="修改站点下的_config"></a>修改站点下的_config</h3><p>在该文件下修改theme，大约位于上次修改的位置上一行<br>theme: next</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>在网上可以找到官方文档进行修改</p>
<hr>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>新的尝试</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习（5）</title>
    <url>/post/8ee23984.html</url>
    <content><![CDATA[<p>常用类，包装类，String类</p>
<a id="more"></a>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类均位于java.lang包，八种包装类和基本数据类型的对应关系如图<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495593568889579.png" alt="八中包装类"></p>
<p>为什么要把基本类型包装成对象？<br>首先是应该是保留基本类型，基本类型是在栈中，而包装成类中则是从栈中调取堆中的数据，相比于包装类使用基本数据更加高效。<br>包装类的优点则是，因为Java的思想是面向对象，所以在使用容器的时候调动是对象。再就是包装成对象可以使用类中的方法。</p>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><ol>
<li><p>自动装箱</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Integer</span> i = <span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="comment">//相当于编译器自动为您作以下的语法编译：</span></span><br><span class="line"><span class="keyword">Integer</span> i = <span class="keyword">Integer</span>.valueOf(<span class="number">100</span>);<span class="comment">//调用的是valueOf(100)，而不是new Integer(100)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自动拆箱<br>每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用intValue()、doubleValue()等转型方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span> j = i;<span class="comment">//自动拆箱</span></span><br><span class="line"><span class="comment">//相当于编译器自动为您作以下的语法编译：</span></span><br><span class="line"><span class="built_in">int</span> j = i.<span class="built_in">int</span>Value();</span><br></pre></td></tr></table></figure>
</li>
<li><p>空指针异常问题<br>在自动装箱和拆箱的过程中，由于是自动调用方法，可能会导致发安生null.方法名的空指针异常。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = null;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以此为例在int j=i的时候，是调用的int j=i.intValue(),i此时为空，产生了空指针异常。</p>
<ol start="4">
<li>包装类的缓存问题<br>整型、char类型所对应的包装类，在自动装箱时，对于-128<del>127之间的值会进行缓存处理，其目的是提高效率。<br>缓存处理的原理为：如果数据在-128</del>127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。<br>内存地址的引用：<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495596432165735.png" alt="缓存的地址"><br><font color="red">也就是说在-128~127之间的数是引用的同一个地址（在类加载完成时就产生了这些数），而在此之外的数则不是引用的同一个地址</font></li>
</ol>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>String对象称为“不可变对象”。String的内容只能赋值一次（是fail修饰的），如果对一个String多次赋值会造成内存问题所以就引入了StringBuffer和StringBuilder</p>
<ol>
<li><p>String类基础  </p>
<blockquote>
<p>1.String类又称作不可变字符序列。  </p>
</blockquote>
</li>
<li><p>String位于java.lang包中，Java程序默认导入java.lang包下的所有类。  </p>
</li>
<li><p>Java字符串就是Unicode字符序列，例如字符串“Java”就是4个Unicode字符’J’、’a’、’v’、’a’组成的。  </p>
</li>
<li><p>Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。  </p>
</li>
<li><p>常量池</p>
<blockquote>
<ol>
<li>全局字符串常量池(String Pool)<br>全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值(在堆中生成字符串对象实例)。</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<ol start="2">
<li>class文件常量池(Class Constant Pool)<br>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量(文本字符串、final常量等)和符号引用。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>运行时常量池(Runtime Constant Pool)<br>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。  </li>
</ol>
</blockquote>
<h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h2><p> StringBuffer和StringBuilder非常类似，均代表可变的字符序列。 这两个类都是抽象类AbstractStringBuilder的子类，方法几乎一模一样。</p>
<blockquote>
<p>1.StringBuffer JDK1.0版本提供的类，线程安全，做线程同步检查， 效率较低。<br>2.StringBuilder JDK1.5版本提供的类，线程不安全，不做线程同步检查，因此效率较高。 建议采用该类。</p>
</blockquote>
<p>常用方法列表</p>
<ol>
<li>重载的public StringBuilder append(…)方法  <blockquote>
<p>可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。</p>
</blockquote>
</li>
<li>方法 public StringBuilder delete(int start,int end)<blockquote>
<p>可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。</p>
</blockquote>
</li>
<li>方法 public StringBuilder deleteCharAt(int index)<blockquote>
<p>移除此序列指定位置上的 char，仍然返回自身对象。</p>
</blockquote>
</li>
<li>重载的public StringBuilder insert(…)方法<blockquote>
<p>可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。</p>
</blockquote>
</li>
<li>方法 public StringBuilder reverse()<blockquote>
<p>用于将字符序列逆序，仍然返回自身对象。</p>
</blockquote>
</li>
<li>方法 public String toString() <blockquote>
<p>返回此序列中数据的字符串表示形式。</p>
</blockquote>
</li>
<li>和 String 类含义类似的方法：<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">int</span> indexOf(String str)</span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> indexOf(String str,<span class="type">int</span> fromIndex)</span><br><span class="line"><span class="built_in">public</span> String substring(<span class="type">int</span> <span class="keyword">start</span>)</span><br><span class="line"><span class="built_in">public</span> String substring(<span class="type">int</span> <span class="keyword">start</span>,<span class="type">int</span> <span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> length() </span><br><span class="line"><span class="type">char</span> charAt(<span class="type">int</span> <span class="keyword">index</span>)</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/post/5729df21.html</url>
    <content><![CDATA[<p>多线程入门</p>
<a id="more"></a>
<h2 id="基本概念呢"><a href="#基本概念呢" class="headerlink" title="基本概念呢"></a>基本概念呢</h2><p>###程序：<br>“程序(Program)”是一个静态的概念，一般对应于操作系统中的一个可执行文件，比如：我们要启动酷狗听音乐，则对应酷狗的可执行程序。当我们双击酷狗，则加载程序到内存中，开始执行该程序，于是产生了“进程”。  </p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>执行中的程序叫做进程(Process)，是一个动态的概念。现代的操作系统都可以同时启动多个进程。比如：我们在用酷狗听音乐，也可以使用eclipse写代码，也可以同时用浏览器查看网页。  </p>
<p>进程的特点：</p>
<blockquote>
<ol>
<li>进程是程序的一次动态执行过程， 占用特定的地址空间。</li>
<li>每个进程由3部分组成：cpu、data、code。每个进程都是独立的，保有自己的cpu时间，代码和数据，即便用同一份程序产生好几个进程，它们之间还是拥有自己的这3样东西，这样的缺点是：浪费内存，cpu的负担较重。</li>
<li>多任务(Multitasking)操作系统将CPU时间动态地划分给每个进程，操作系统同时执行多个进程，每个进程独立运行。以进程的观点来看，它会以为自己独占CPU的使用权。 </li>
</ol>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以产生多个线程。同多个进程可以共享操作系统的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源(比如：代码、数据)，所以线程又被称为轻量级进程(lightweight process)。</p>
<blockquote>
<ol>
<li>一个进程内部的一个执行单元，它是程序中的一个单一的顺序控制流程。</li>
<li>一个进程可拥有多个并行的(concurrent)线程。</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且它们从同一堆中分配对象并进行通信、数据交换和同步操作。</li>
<li>由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快。</li>
<li>线程的启动、中断、消亡，消耗的资源非常少。</li>
</ol>
</blockquote>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote>
<ol>
<li>每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。</li>
<li>线程可以看成是轻量级的进程，属于同一进程的线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。</li>
<li>线程和进程最根本的区别在于：进程是资源分配的单位，线程是调度和执行的单位。</li>
<li>多进程: 在操作系统中能同时运行多个任务(程序)。</li>
<li>多线程: 在同一应用程序中有多个顺序流同时执行。</li>
<li>线程是进程的一部分，所以线程有的时候被称为轻量级进程。</li>
<li>一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，进程的执行过程不是一条线(线程)的，而是多条线(线程)共同完成的。</li>
<li>系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存(线程所使用的资源是它所属的进程的资源)，线程组只能共享资源。那就是说，除了CPU之外(线程在运行的时候要占用CPU资源)，计算机内部的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li>
</ol>
</blockquote>
<h2 id="java实现多线程的三种方式"><a href="#java实现多线程的三种方式" class="headerlink" title="java实现多线程的三种方式"></a>java实现多线程的三种方式</h2><ol>
<li>继承Thread类</li>
<li>实现Runable接口</li>
<li>实现Callable接口（了解）</li>
</ol>
<h2 id="多线程-继承Tread"><a href="#多线程-继承Tread" class="headerlink" title="多线程_继承Tread"></a>多线程_继承Tread</h2><p>继承Thread类实现多线程的步骤：</p>
<blockquote>
<ol>
<li>在Java中负责实现线程功能的类是java.lang.Thread 类。</li>
<li>可以通过创建 Thread的实例来创建新的线程。</li>
<li>每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。</li>
<li>通过调用Thread类的start()方法来启动一个线程</li>
</ol>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><span class="comment">//自定义类继承Thread类</span></span><br><span class="line">    <span class="comment">//run()方法里是线程体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + i);<span class="comment">//getName()方法是返回线程名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        TestThread thread1 = <span class="keyword">new</span> TestThread();<span class="comment">//创建线程对象</span></span><br><span class="line">        thread1.start();<span class="comment">//启动线程</span></span><br><span class="line">        TestThread thread2 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程-实现Rubable接口"><a href="#多线程-实现Rubable接口" class="headerlink" title="多线程_实现Rubable接口"></a>多线程_实现Rubable接口</h2><p>由于继承只能单继承，在继承Thread后无法继承其他类，这时候便是Rubable的时候了，可以实现Runable接口。<font color="red">推荐使用实现Runable</font>（底层上Thread类是实现了Runable接口）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><span class="comment">//自定义类实现Runnable接口；</span></span><br><span class="line">    <span class="comment">//run()方法里是线程体；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象，把实现了Runnable接口的对象作为参数传入；</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread2());</span><br><span class="line">        thread1.start();<span class="comment">//启动线程；</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread2());</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟抢票"><a href="#模拟抢票" class="headerlink" title="模拟抢票"></a>模拟抢票</h3><p>同一份资源多个代理，就容易出现并发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickt</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"********"</span>+ticket--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Tickt t=<span class="keyword">new</span> Tickt();</span><br><span class="line">		<span class="keyword">new</span> Thread(t,<span class="string">"zhangsan"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(t,<span class="string">"lisi"</span>).start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据的异常</p>
<blockquote>
<p>………<br>lisi<code>********</code>4<br>zhangsan<code>********</code>3<br>lisi<code>********</code>2<br>zhangsan<code>********</code>1<br>lisi<code>********</code>0<br>zhangsan<code>********</code>-1  </p>
</blockquote>
<h3 id="模拟龟兔赛跑"><a href="#模拟龟兔赛跑" class="headerlink" title="模拟龟兔赛跑"></a>模拟龟兔赛跑</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> ImpRunble implements Runnable &#123;</span><br><span class="line">	<span class="keyword">private</span> String winner;</span><br><span class="line">	@Override</span><br><span class="line">	public void run<span class="literal">()</span> &#123;</span><br><span class="line">		for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>.equals(<span class="string">"兔子"</span>)&amp;&amp;i%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+i);	</span><br><span class="line">		boolean flag=gameover(i);</span><br><span class="line">		<span class="keyword">if</span> (flag==<span class="literal">true</span>) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> boolean gameover(<span class="built_in">int</span> i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(winner!=null) &#123;	</span><br><span class="line">		return <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">100</span>) &#123;</span><br><span class="line">			winner=<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">			<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"胜利者："</span>+<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">	ImpRunble ir=<span class="keyword">new</span> <span class="constructor">ImpRunble()</span>;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">new</span> <span class="constructor">Thread(<span class="params">ir</span>,<span class="string">"乌龟"</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">	<span class="keyword">new</span> <span class="constructor">Thread(<span class="params">ir</span>,<span class="string">"兔子"</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170526/1495787690411518.png" alt="线程状态"></p>
<p>一个线程对象存在五个状态：</p>
<ol>
<li><p>新生状态(New)</p>
<blockquote>
<p>用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。</p>
</blockquote>
</li>
<li><p>就绪状态(Runnable)</p>
<blockquote>
<p>处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：</p>
<blockquote>
<ol>
<li>新建线程：调用start()方法，进入就绪状态;</li>
<li>阻塞线程：阻塞解除，进入就绪状态;</li>
<li>运行线程：调用-方法，直接进入就绪状态;</li>
<li>运行线程：JVM将CPU资源从本线程切换到其他线程。</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>运行状态(Running)</p>
<blockquote>
<p>在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。</p>
</blockquote>
</li>
<li><p>阻塞状态(Blocked)</p>
<blockquote>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。有4种原因会导致阻塞：</p>
<blockquote>
<ol>
<li>执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。</li>
<li>执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。</li>
<li>线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。</li>
<li>join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>死亡状态(Terminated)</p>
<blockquote>
<p>死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法内的全部工作; 另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。<br>当一个线程进入死亡状态以后，就不能再回到其它状态了。</p>
</blockquote>
</li>
</ol>
<h2 id="线程的阻塞与就绪状态"><a href="#线程的阻塞与就绪状态" class="headerlink" title="线程的阻塞与就绪状态"></a>线程的阻塞与就绪状态</h2><p>对于暂停线程，暂停线程执行常用的方法有sleep()和yield()方法，这两个方法的区别是：</p>
<ol>
<li>sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。</li>
<li>yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。</li>
</ol>
<h3 id="线程阻塞-sleep"><a href="#线程阻塞-sleep" class="headerlink" title="线程阻塞-sleep()"></a>线程阻塞-sleep()</h3><ol>
<li>sleep（时间）指定当前线程阻塞的毫秒数</li>
<li>sleep平存在异常InterruptedException</li>
<li>sleep时间到达后进入就绪状态</li>
<li>sleep可以模拟网络延时、倒计时等</li>
<li>每一个对象都有一个锁，sleep不会释放锁</li>
</ol>
<p>相关代码可以参考之前的模拟抢票</p>
<h3 id="线程阻塞-join"><a href="#线程阻塞-join" class="headerlink" title="线程阻塞-join()"></a>线程阻塞-join()</h3><p>join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Testjoin</span> &#123;</span></span><br><span class="line">public static <span class="literal">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	Thread t=<span class="keyword">new</span> Thread<span class="function"><span class="params">(()-&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">			System.out.println(Thread.currentThread().getName()+<span class="string">"---------"</span>+i);</span></span></span><br><span class="line"><span class="function"><span class="params">		&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">	&#125;)</span>;</span></span><br><span class="line"><span class="function">	<span class="title">t</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">	<span class="title">for</span><span class="params">(int j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span> &#123;</span></span><br><span class="line"><span class="function">		<span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(Thread.currentThread().getName()+<span class="string">"##########"</span>+j)</span>;</span></span><br><span class="line"><span class="function">		<span class="title">if</span><span class="params">(j==<span class="number">5</span>)</span> &#123;</span></span><br><span class="line"><span class="function">			<span class="title">t</span>.<span class="title">join</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">		&#125;</span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>(在main线程里使用join()阻塞main线程，执行完t线程后再次使用面线程)<br>结果：</p>
<blockquote>
<p>main##########5<br>Thread-0———9<br>main##########6<br>main##########7  </p>
</blockquote>
<h3 id="线程就绪-yield"><a href="#线程就绪-yield" class="headerlink" title="线程就绪-yield()"></a>线程就绪-yield()</h3><p>礼让线程，当前正在执行的线程暂停<br>线程从运行状态到就绪状态<br>让CPU重新调度</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Snippet &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">		Yield y=<span class="keyword">new</span> <span class="constructor">Yield()</span>;</span><br><span class="line">		<span class="keyword">new</span> <span class="constructor">Thread(<span class="params">y</span>,<span class="string">"a"</span>)</span>.start<span class="literal">()</span>;;</span><br><span class="line">		<span class="keyword">new</span> <span class="constructor">Thread(<span class="params">y</span>,<span class="string">"b"</span>)</span>.start<span class="literal">()</span>;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Yield implements Runnable&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run<span class="literal">()</span> &#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">"----&gt;start"</span>);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>yield<span class="literal">()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>+<span class="string">"-----&gt;end"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取线程基本信息的方法"><a href="#获取线程基本信息的方法" class="headerlink" title="获取线程基本信息的方法"></a>获取线程基本信息的方法</h2><p><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170526/1495789884517307.png" alt=""></p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><ol>
<li>处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。</li>
<li>线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。(优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程)</li>
<li>使用下列方法获得或设置线程对象的优先级。<br><code>int getPriority();</code><br><code>void setPriority(int newPriority);</code></li>
</ol>
<p>设置优先级要在start（）之前</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">t1</span>.setPriority(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">t2</span>.setPriority(<span class="number">10</span>);</span><br><span class="line"> <span class="built_in">t1</span>.start();</span><br><span class="line"> <span class="built_in">t2</span>.start();</span><br><span class="line">```		</span><br><span class="line"></span><br><span class="line"><span class="comment">## 守护线程</span></span><br><span class="line"><span class="keyword">Java程序入口就是由JVM启动main线程，main线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</span></span><br><span class="line"><span class="keyword">如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</span></span><br><span class="line"><span class="keyword">但是有一种线程的目的就是无限循环，如果不结束，jvm就无法退出。标记了守护线程则不会等待该线程结束，当普通线程结束后，jvm就会退出。</span></span><br><span class="line"><span class="keyword">守护线程的使用：</span></span><br></pre></td></tr></table></figure>
<p>Thread t = new MyThread();<br>t.setDaemon(true);<br>t.start();</p>
<pre><code>
&gt;守护线程是为其他线程服务的线程；  
所有非守护线程都执行完毕后，虚拟机退出；  
守护线程不能持有需要关闭的资源（如打开文件等）。 </code></pre>]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java复习（3）</title>
    <url>/post/ab896658.html</url>
    <content><![CDATA[<p>数组</p>
<a id="more"></a>
<h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><p>数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个元素，每个元素可以通过一个索引(下标)来访问它们。</p>
<p>数组的三个基本特点：</p>
<blockquote>
<p>1.长度是确定的。数组一旦被创建，它的大小就是不可以改变的。<br>2.其元素必须是相同类型，不允许出现混合类型。<br>3.数组类型可以是任何数据类型，包括基本类型和引用类型。  </p>
</blockquote>
<h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><p>定义方式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>[]   <span class="title">arr_name</span></span>; <span class="comment">//（推荐使用这种方式）</span></span><br><span class="line"><span class="class"><span class="keyword">type</span>    <span class="title">arr_name</span>[]</span>;</span><br></pre></td></tr></table></figure>

<p>数组声明的时候没有数组真正被创建，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。<br>以这张图为例，这是基本类型的数组。声明时候int[] a;此时在栈内存有了一个a，然后new int[10]的时候，在堆内存创建一个大小为10的一个数组对象，栈指向堆的地址，后面就可以在循环遍历赋值。<br><img src="https://www.sxt.cn/360shop/Public/admin/UEditor/20170522/1495418560857133.png" alt="数组堆栈内存"></p>
<p>至于引用类型的数组就是把建的数组的对象被数组引用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Csh[] csh=new Csh[<span class="number">10</span>];<span class="comment">//定义Csh类型的数组，并在堆中创建</span></span><br><span class="line">csh[<span class="number">0</span>]=new Csh(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//将下标0的数组指向new的对象的地址</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化<br>静态与动态初始化自我理解，静态直接赋值（静态的理解或许就是从方法区拿值给数组），动态是后面赋值。</p>
<ol>
<li>静态初始化  </li>
</ol>
<p>除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">// 静态初始化基本类型数组；</span></span><br><span class="line">Man[] mans = &#123; new Man(<span class="number">1</span>, <span class="number">1</span>), new Man(<span class="number">2</span>, <span class="number">2</span>) &#125;;<span class="comment">// 静态初始化引用类型数组；</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>动态初始化</li>
</ol>
<p>数组定义与为数组元素分配空间并赋值的操作分开进行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a1 = new <span class="built_in">int</span>[<span class="number">2</span>];<span class="comment">//动态初始化数组，先分配空间；</span></span><br><span class="line">a1[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//给数组元素赋值；</span></span><br><span class="line">a1[<span class="number">1</span>]=<span class="number">2</span>;<span class="comment">//给数组元素赋值；</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认初始化</li>
</ol>
<p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// 默认值：0,0</span></span><br><span class="line"><span class="keyword">boolean</span>[] b = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>]; <span class="comment">// 默认值：false,false</span></span><br><span class="line"><span class="keyword">String</span>[] s = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">2</span>]; <span class="comment">// 默认值：null, null</span></span><br></pre></td></tr></table></figure>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>for循环可以对数组进行赋值和读值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = <span class="number">100</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取元素的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(a[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>foreach只能进行读值</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String <span class="keyword">temp</span> : ss) &#123;</span><br><span class="line">          <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">temp</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组拷贝arraycopy的多种用法"><a href="#数组拷贝arraycopy的多种用法" class="headerlink" title="数组拷贝arraycopy的多种用法"></a>数组拷贝arraycopy的多种用法</h2><p>除了拷贝，还可以删除数组元素，增加数组元素<br>原理是拷贝除了拷贝到其他数组，还可以自身拷贝<br><code>System.arraycopy(src, srcPos, dest, destPos, length);</code><br>src：要复制的数组(源数组)<br>srcPos：复制源数组的起始位置<br>dest：目标数组<br>destPos：目标数组的下标位置<br>length：要复制的长度  </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testcopyal</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">String</span>[] a=&#123;<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">		Testcopyal.copy(a, index);	</span><br><span class="line">		Testcopyal.extend(a);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//根据传入的参数为删除的元素的序列，删除传入数组的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">String</span>[] a,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	System.arraycopy(a,index+<span class="number">1</span>, a,index, a.length-index<span class="number">-1</span>);</span><br><span class="line">	a[a.length<span class="number">-1</span>]=null;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">String</span> c:a) &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"************************************"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并数组</span></span><br><span class="line"><span class="comment">//先将数组a利用c进行扩容，将c数组作为a数组，把b数组增到a数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">String</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">String</span>[] b= &#123;<span class="string">"dd"</span>,<span class="string">"ee"</span>,<span class="string">"ff"</span>&#125;;</span><br><span class="line">	<span class="keyword">String</span>[] c=<span class="keyword">new</span> <span class="keyword">String</span>[a.length+b.length];</span><br><span class="line">	System.arraycopy(a, <span class="number">0</span>, c, <span class="number">0</span>, a.length);</span><br><span class="line">	System.arraycopy(b, <span class="number">0</span>, c, a.length, b.length);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">String</span> d:c) &#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java-util-Arrays类的使用"><a href="#java-util-Arrays类的使用" class="headerlink" title="java.util.Arrays类的使用"></a>java.util.Arrays类的使用</h2><p>JDK提供的java.util.Arrays类，包含了常用的数组操作，方便我们日常开发。Arrays类包含了：排序、查找、填充、打印内容等常见的操作。</p>
<h3 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String args[]) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(a); <span class="comment">// 打印数组引用的值；</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(a)); <span class="comment">// 打印数组元素的值；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组元素的排序"><a href="#数组元素的排序" class="headerlink" title="数组元素的排序"></a>数组元素的排序</h3><p>引用类型的排序(Comparable接口的应用)</p>
<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public <span class="keyword">class</span> Test &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="built_in">int</span><span class="literal">[]</span> a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">323</span>,<span class="number">23</span>,<span class="number">543</span>,<span class="number">12</span>,<span class="number">59</span>&#125;;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(a);   <span class="comment">//使用二分法查找，必须先对数组进行排序;</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">a</span>)</span>);</span><br><span class="line">        <span class="comment">//返回排序后新的索引位置,若未找到返回负数。</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"该元素的索引："</span>+<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>binary<span class="constructor">Search(<span class="params">a</span>, 12)</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] a= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">323</span>,<span class="number">23</span>,<span class="number">543</span>,<span class="number">12</span>,<span class="number">59</span>&#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(a));</span><br><span class="line">        Arrays.fill(a, <span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>);  <span class="comment">//将2到4索引的元素替换为100;</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="二维数组的声明"><a href="#二维数组的声明" class="headerlink" title="二维数组的声明"></a>二维数组的声明</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">// Java中多维数组的声明和初始化应按从低维到高维的顺序进行</span></span><br><span class="line">        <span class="built_in">int</span>[][] a = new <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line">        a[<span class="number">0</span>] = new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">1</span>] = new <span class="built_in">int</span>[<span class="number">4</span>];</span><br><span class="line">        a[<span class="number">2</span>] = new <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// int a1[][]=new int[][4];//非法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的静态初始化"><a href="#二维数组的静态初始化" class="headerlink" title="二维数组的静态初始化"></a>二维数组的静态初始化</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] a = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125; &#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(a[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的动态初始化"><a href="#二维数组的动态初始化" class="headerlink" title="二维数组的动态初始化"></a>二维数组的动态初始化</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[][] a = new <span class="built_in">int</span>[<span class="number">3</span>][];</span><br><span class="line">        <span class="comment">// a[0] = &#123;1,2,5&#125;; //错误，没有声明类型就初始化</span></span><br><span class="line">        a[<span class="number">0</span>] = new <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        a[<span class="number">1</span>] = new <span class="built_in">int</span>[] &#123; <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        a[<span class="number">2</span>] = new <span class="built_in">int</span>[] &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(a[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(a[<span class="number">0</span>]));</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(a[<span class="number">1</span>]));</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(a[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
