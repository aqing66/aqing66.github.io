<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javaweb复习（2）</title>
    <url>/post/ff269a0a.html</url>
    <content><![CDATA[<p>javaweb的第二段的复习，由于家里事致使每天的复习量很少，一天一点，也要加油复习呀！</p>
<a id="more"></a>
<h2 id="1-JDBC-Java-DataBase-Connectivity"><a href="#1-JDBC-Java-DataBase-Connectivity" class="headerlink" title="1.JDBC:Java DataBase Connectivity"></a>1.JDBC:Java DataBase Connectivity</h2><p>可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库</p>
<h2 id="2-JDBC-API-主要功能："><a href="#2-JDBC-API-主要功能：" class="headerlink" title="2.JDBC API 主要功能："></a>2.JDBC API 主要功能：</h2><h3 id="1-三件事，具体是通过以下类-接口实现："><a href="#1-三件事，具体是通过以下类-接口实现：" class="headerlink" title="1. 三件事，具体是通过以下类/接口实现："></a>1. 三件事，具体是通过以下类/接口实现：</h3><p>DriverManager ： 管理jdbc驱动<br>Connection： 连接（通过DriverManager产生）<br>Statement（PreparedStatement） ：增删改查  （通过Connection产生 ）<br>CallableStatement  ： 调用数据库中的 存储过程/存储函数  （通过Connection产生 ）<br>Result ：返回的结果集  （上面的Statement等产生 ）<br><img src="https://tva2.sinaimg.cn/large/0072kSCply1ggrzrexxxaj30vh0fwdgu.jpg" alt="jdbc架构"></p>
<h3 id="2-相关类的解释"><a href="#2-相关类的解释" class="headerlink" title="2. 相关类的解释"></a>2. 相关类的解释</h3><p>Connection产生操作数据库的对象：<br>Connection产生Statement对象：createStatement()<br>Connection产生PreparedStatement对象：prepareStatement()<br>Connection产生CallableStatement对象：prepareCall();  </p>
<p>Statement操作数据库：<br>增删改：executeUpdate()<br>查询：executeQuery();</p>
<p>ResultSet：保存结果集 select * from xxx<br>next():光标下移，判断是否有下一条数据；true/false<br>previous():  true/false<br>getXxx(字段名|位置):获取具体的字段值  </p>
<p>PreparedStatement操作数据库：<br>public interface PreparedStatement extends Statement<br>因此有<br>增删改：executeUpdate()<br>查询：executeQuery();<br>–此外<br>赋值操作 setXxx();</p>
<h3 id="3-PreparedStatement与Statement在使用时的区别："><a href="#3-PreparedStatement与Statement在使用时的区别：" class="headerlink" title="3. PreparedStatement与Statement在使用时的区别："></a>3. PreparedStatement与Statement在使用时的区别：</h3><p>1.Statement:<br>sql<br>executeUpdate(sql)  </p>
<p>2.PreparedStatement:<br>sql(可能存在占位符?)<br>在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql)<br>executeUpdate()<br>setXxx()替换占位符？ </p>
<p>PreparedStatement的优势<br>1.编码更加简便（避免了字符串的拼接）<br>2.提高性能(因为 有预编译操作，预编译只需要执行一次)<br>3.安全（可以有效防止sql注入）</p>
<h3 id="4-关于SQL注入问题"><a href="#4-关于SQL注入问题" class="headerlink" title="4. 关于SQL注入问题"></a>4. 关于SQL注入问题</h3><p>利用“符号将查询的字段结束并在后面加上恒等式<br>例如输入  用户名：任意值 ‘ or 1=1 - -<br>       密码：任意值</p>
<h3 id="5-jdbc总结（模板）："><a href="#5-jdbc总结（模板）：" class="headerlink" title="5. jdbc总结（模板）："></a>5. jdbc总结（模板）：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">a.导入驱动包、加载具体驱动类Class.forName(&quot;具体驱动类&quot;);  </span><br><span class="line">b.与数据库建立连接connection &#x3D; DriverManager.getConnection(...);  </span><br><span class="line">c.通过connection，获取操作数据库的对象  （Statement\preparedStatement\callablestatement）</span><br><span class="line">stmt &#x3D; connection.createStatement();  </span><br><span class="line">d.(查询)处理结果集rs &#x3D; pstmt.executeQuery()  </span><br><span class="line">while(rs.next())&#123; rs.getXxx(..) ;&#125;   </span><br><span class="line">&#125;catch(ClassNotFoundException e  )  </span><br><span class="line">&#123; ...&#125;  </span><br><span class="line">catch(SQLException e)   </span><br><span class="line">&#123;... </span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;...</span><br><span class="line">&#125;</span><br><span class="line">finally</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;打开顺序，与关闭顺序相反</span><br><span class="line">	if(rs!&#x3D;null)rs.close()</span><br><span class="line">	if(stmt!&#x3D;null) stmt.close();</span><br><span class="line">	if(connection!&#x3D;null)connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException</span><br></pre></td></tr></table></figure>

<h3 id="6-CallableStatement-调用-存储过程、存储函数"><a href="#6-CallableStatement-调用-存储过程、存储函数" class="headerlink" title="6. CallableStatement:调用 存储过程、存储函数"></a>6. CallableStatement:调用 存储过程、存储函数</h3><p>connection.prepareCall(参数：存储过程或存储函数名)<br>参数格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储过程（无返回值return，用out参数替代）：  </span><br><span class="line">	&#123; call  存储过程名(参数列表) &#125;  </span><br><span class="line">存储函数（有返回值return）：  </span><br><span class="line">	&#123; ? &#x3D; call  存储函数名(参数列表) &#125;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace procedure addTwoNum ( num1  in number,num2  in number,result out number )  -- 1 + 2 -&gt;3</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">	result :&#x3D; num1+num2 ;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure>


<p>强调：<br>如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID<br>通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener</p>
<p>JDBC调用存储过程的步骤：<br>a.产生 调用存储过程的对象（CallableStatement） cstmt =     connection.prepareCall(   “…” ) ;<br>b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);<br>c.通过 registerOutParameter(…)处理输出参数类型<br>d.cstmt.execute()执行<br>e.接受 输出值（返回值）getXxx()  </p>
<p>调存储函数：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create or replace function addTwoNumfunction ( num1  in number,num2  in number)  -- 1 + 2 </span><br><span class="line">return number</span><br><span class="line">as</span><br><span class="line">	result number ;	</span><br><span class="line">begin</span><br><span class="line">	result :&#x3D; num1+num2 ;</span><br><span class="line">	return result ;</span><br><span class="line">end ;</span><br></pre></td></tr></table></figure>
<p>JDBC调用存储函数：与调存储过程的区别：<br>在调用时，注意参数：”{? =  call addTwoNumfunction    (?,?) }”</p>
<h3 id="7-处理CLOB-BLOB类型"><a href="#7-处理CLOB-BLOB类型" class="headerlink" title="7. 处理CLOB/BLOB类型"></a>7. 处理CLOB/BLOB类型</h3><p>处理稍大型数据：  </p>
<p>a.存储路径    E:\JDK_API_zh_CN.CHM<br>    通过JDBC存储文件路径，然后 根据IO操作处理<br>    例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式  “E:\JDK_API_zh_CN.CHM”存储到数据库中<br>        获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  2.IO      </p>
<p>b.<br>    CLOB：大文本数据 （小说-&gt;数据）<br>    BLOB：二进制  </p>
<p>clob:大文本数据   字符流 Reader Writer  </p>
<p>存<br>1.先通过pstmt 的? 代替小说内容 （占位符）<br>2.再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型</p>
<p>取：<br>1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中<br>2.将Reader通过Writer输出即可。</p>
<p>blob:二进制  字节流 InputStream OutputStream<br>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)   </p>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb复习（1）——jsp</title>
    <url>/post/215a6388.html</url>
    <content><![CDATA[<p>在之前的小组的项目开发中发现自己的知识并不牢固，希望通过基础知识再次学习查找不足，先通过Javaweb的jsp的开发过程和Java基础并行作为起点开始学习</p>
<a id="more"></a>
<h2 id="jsp执行流程"><a href="#jsp执行流程" class="headerlink" title="jsp执行流程"></a>jsp执行流程</h2><p>第一次访问：客户端发出请求，服务端接收到jsp,jsp编译成Java（servlet），然后编译成.class。服务端将结果返回客户端</p>
<ul>
<li>过程介绍</li>
</ul>
<p>客户端发出请求，请求为JSP，web容器就会找出相应的servlet进行处理。<br>将servlet转成字节码文件。<br>将字节码文件加载到web容器里。<br>这时会在web容器里建立实例。<br>进行初始化。<br>通过service接受请求。<br>然后web容器会自动产生两个对象servlet和service最后进行销毁。<br><img src="https://iknow-pic.cdn.bcebos.com/1f178a82b9014a90a9e9e414a7773912b21bee40" alt="图片链接"></p>
<p>第二次访问；未修改代码情况下直接访问.class返回客户端</p>
<h2 id="jsp页面元素和request请求"><a href="#jsp页面元素和request请求" class="headerlink" title="jsp页面元素和request请求"></a>jsp页面元素和request请求</h2><h3 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h3><p> html、Java代码（脚本scriptlet）、注释、指令</p>
<ol>
<li>HTML代码</li>
<li>Java代码（脚本scriptlet）</li>
</ol>
<ul>
<li>全局变量、定义方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">public String bookName</span><br><span class="line">public void init()&#123;</span><br><span class="line">   bookName &#x3D;&quot;java书&quot;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li>
<li>局部变量、Java代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">String name &#x3D;&quot;zhangsan&quot;;</span><br><span class="line">out.print(&quot;hello&quot;+name);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li>
<li>输出表达式 <font color="red">结尾没有分号</font><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%&#x3D;&quot;hello&quot;+bookName%&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>指令<br>例子:page指令<br>language；jsp页面使用的脚本语言<br>import: 导入的类<br>pageEncode：jsp自身编码 jsp -&gt;java<br>contentType: 浏览器解析jsp的编码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page  &gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="4">
<li>注释<br>HTML注释: &lt;!– – &gt;<br>Java注释: //和/*  */<br>jsp注释 &lt;%–  –%&gt;  <h3 id="get和post提交方式"><a href="#get和post提交方式" class="headerlink" title="get和post提交方式"></a>get和post提交方式</h3>get提交方式：method=“get”、地址栏、超链接（<code>&lt;a href=&quot;xx&quot;&gt;</code>）请求方式默认都是get<h3 id="get和post请求方式区别"><a href="#get和post请求方式区别" class="headerlink" title="get和post请求方式区别"></a>get和post请求方式区别</h3><blockquote>
<p>1.get在地址栏显示提交内容，post不是显示(get的提交的内容有限大约3kb)<br>2.文件上传按时必须post(get不安全)</p>
</blockquote>
</li>
</ol>
<h3 id="jsp-九大内置对象"><a href="#jsp-九大内置对象" class="headerlink" title="jsp 九大内置对象"></a>jsp 九大内置对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1.out javax.servlet.jsp.jspWriter 页面输出<br>2.request javax.servlet.http.HttpServletrequest 获取用户的请求信息<br>3.response javax.servlet.http.HttpServletResponse 服务器向客户端的回应信息<br>4.session javax.servlet.http.HttpSession 用来保存每一个用户的信息<br>5.application javax.servlet.ServletContext 表示所有用户的共享信息<br>6.config javax.servlet.ServletConfig 服务器配置信息，可以取得初始化参数<br>7.PageContext javax.servlet.jsp.PageContext JSP的页面容器<br>8.page java.lang.object)   当前JSP页面对象（相当于java中的this）<br>9.exception java.lang.Throwable 异常对象</p>
<h4 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h4><h5 id="out：-输出对象，向客户端输出内容"><a href="#out：-输出对象，向客户端输出内容" class="headerlink" title="out： 输出对象，向客户端输出内容"></a>out： 输出对象，向客户端输出内容</h5><h5 id="request-请求对象；储存“客户端向服务器发送请求消息”"><a href="#request-请求对象；储存“客户端向服务器发送请求消息”" class="headerlink" title="request: 请求对象；储存“客户端向服务器发送请求消息”"></a>request: 请求对象；储存“客户端向服务器发送请求消息”</h5><blockquote>
<p>request对象常方法</p>
<blockquote>
<p>String getParamete(String name) :根据请求字段名key，返回返回值value。<font color="red">k是name</font><br>String[] getParameteValues(String name):f返回多个值（checkbox)<br>void setCharacterEncoding(“utf-8”):请求编码格式<br>getRequestDispathcher(“jsp”).forward(requset,response):请求转发<br>getServerContext():获取项目的ServletContext对象</p>
</blockquote>
</blockquote>
<blockquote>
<p>requset的编码格式异常问题  </p>
<blockquote>
<p>get方式有问题的话更改Tomcat到8以上<br>post方式有问题添加requset.setCharacterEncoding(“utf-8”)在请求的头部</p>
</blockquote>
</blockquote>
<h5 id="response：响应对象；"><a href="#response：响应对象；" class="headerlink" title="response：响应对象；"></a>response：响应对象；</h5><blockquote>
<p>提供方法</p>
<blockquote>
<p>void addCookie(Cookiie cookie):服务端向客户端增加cookie对象<br>void senredirect（”.jsp“） throw IOException:页面跳转重定向<br>void setContentType（string type）；设置服务器响应的编码（设置服务器的ContentType类型）</p>
</blockquote>
</blockquote>
<blockquote>
<p>关于重定向和请求转发</p>
<blockquote>
<p>重定向有response提供，但是数据丢失，页面地址改变<br>两次请求两次响应<br>请求转发是由request提供，数据不丢失，页面地址不变（保留转发前的地址）<br>一次请求一次响应</p>
</blockquote>
</blockquote>
<h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><blockquote>
<p>方法 </p>
<blockquote>
<p>String getId() :获取sessionId<br>boolean isNew() :判断是否是 新用户（第一次访问）<br>void invalidate():使session失效  （退出登录、注销）<br>void setAttribute()<br>Object getAttribute();<br>void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间<br>int getMaxInactiveInterval():获取最大有效 非活动时间  </p>
</blockquote>
</blockquote>
<p><font color="blue">  <em>首先了解session之前需要先了解cookie,cookie不是内置对象</em> </font></p>
<blockquote>
<p>关于cookie</p>
<blockquote>
<p>cookie包含键值对<br>由Java内部类提供的方法</p>
<blockquote>
<p>publice Cookie(String name,String value)<br>String getname()<br>String getValue()<br>void setMaxvalue（intexpire）最大有效期（秒）<br>cookie的使用<br>客户端准备cookieresponse.addCookie（Cookie cookie）<br>页面跳转（转发重定向都可）<br>客户端获取cookie：request.getCookie(); </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><font color="red"> cookie不能取某一个单独对象，只能一次性全部获取</font>  </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；<br>并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);<br>服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；<br>然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；<br>因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li><p>session机制<br>客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；<br>并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);<br>服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；<br>然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；<br>因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）<br>客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID  去服务端的session中匹配sessionid,如果匹配成功（cookie  jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录；</p>
</li>
<li><p>session与cookie<br>seesion 服务端产生 ，内置对象；<br>cookie 客户端产生，不是内置对象（服务器生成，发送给客户端保存）；</p>
</li>
</ul>
<p><font color="red">cookie和session区别</font></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>session</th>
<th>cookie</th>
</tr>
</thead>
<tbody><tr>
<td>保存位置</td>
<td>服务端</td>
<td>客户端</td>
</tr>
<tr>
<td>安全性</td>
<td>较安全</td>
<td>较不安全</td>
</tr>
<tr>
<td>保存的内容</td>
<td>Object</td>
<td>String</td>
</tr>
</tbody></table>
<h5 id="appliation-全局对象"><a href="#appliation-全局对象" class="headerlink" title="appliation 全局对象"></a>appliation 全局对象</h5><p>String getContextPath()    虚拟路径<br>String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径）</p>
<h4 id="四种范围对象（小-gt-大）"><a href="#四种范围对象（小-gt-大）" class="headerlink" title="四种范围对象（小-&gt;大）"></a>四种范围对象（小-&gt;大）</h4><p>pageContext  JSP页面容器   （page对象）； 当前页面有效<br>request   请求对象             同一次请求有效<br>session   会话对象            同一次会话有效<br>appliation 全局对象            全局有效（整个项目有效）</p>
<blockquote>
<p>以上4个对象共有的方法：</p>
<blockquote>
<p>Object getAttribute(String name):根据属性名，或者属性值<br>void setAttribute(String name,Object obj) :设置属性值（新增，修改）<br>setAttribute(“a”,”b”) ;//如果a对象之前不存在，则新建一个a对象 ；<br>                                  如果a之前已经存在，则将a的值改为b<br>void removeAttribute(String name)：根据属性名，删除对象</p>
</blockquote>
</blockquote>
<p>a.pageContext 当前页面有效 (页面跳转后无效)<br>b.request   同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）<br>c.session  同一次会话有效  （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效）<br>d.application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效<br>-&gt;多个项目共享、重启后仍然有效 ：JNDI<br>1.以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；<br>2.以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。</p>
<hr>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb复习（3）</title>
    <url>/post/479afd6f.html</url>
    <content><![CDATA[<p>servlet分为2.5和3.0</p>
<a id="more"></a>
<h2 id="servlet-的基本内容"><a href="#servlet-的基本内容" class="headerlink" title="servlet 的基本内容"></a>servlet 的基本内容</h2><ol>
<li><p>Servlet本质是Java类，实现servlet必须符合一定的规范：  </p>
<blockquote>
<p> a.必须继承  javax.servlet.http.HttpServlet<br>b.重写其中的 doGet()或doPost()方法</p>
<blockquote>
<p>doGet()： 接受 并处 所有get提交方式的请求<br>doPost()：接受 并处 所有post提交方式的请求</p>
</blockquote>
</blockquote>
</li>
<li><p>Servlet要想使用，必须配置</p>
</li>
</ol>
<p>Serlvet2.5：web.xml<br>Servle3.0： @WebServlet</p>
<ol start="3">
<li>项目根目录：WebContent、src（所有的构建路径）  </li>
</ol>
<p>例如：<br>WebContent中有一个文件index.jsp<br>src中有一个Servlet.java    </p>
<p>如果: index.jsp中请求 <code>&lt;a href=&quot;abc&quot;&gt;...&lt;/a&gt;</code> ，则寻找范围：既会在src根目录中找  也会在WebContent根目录中找 (没有先后顺序)</p>
<p>如果：index.jsp中请求<code>&lt;a href=&quot;a/abc&quot;&gt;&lt;/a&gt;</code>，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc</p>
<p>web.xml中的 /:代表<font color="red">项目根路径 </font><br><code>http://localhost:8888/Servlet25Project/</code><br>jsp中的/: <font color="red">服务器根路径 </font><br><code>http://localhost:8888/</code></p>
<h2 id="Servlet流程："><a href="#Servlet流程：" class="headerlink" title="Servlet流程："></a>Servlet流程：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt; 相同名字 &lt;&#x2F;servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt; servlet在项目中的地址 &lt;&#x2F;servlet-class&gt;</span><br><span class="line"> &lt;&#x2F;servlet&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line">   &lt;servlet-name&gt; 相同名字 &lt;&#x2F;servlet-name&gt;</span><br><span class="line">   &lt;url-pattern&gt; 路径名 &lt;&#x2F;url-pattern&gt;</span><br><span class="line"> &lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>请求 -&gt;<code>&lt;url-pattern&gt;</code> -&gt; 根据<code>&lt;servlet-mapping&gt;</code>中的<code>&lt;servlet-name&gt;</code>去匹配  <code>&lt;servlet&gt;</code>中的<code>&lt;servlet-name&gt;</code>，然后寻找到<code>&lt;servlet-class&gt;</code>，求中将请求交由该<code>&lt;servlet-class&gt;</code>执行。  </p>
<p>Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)<br>匹配流程：  请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类</p>
<h2 id="Servlet生命周期：5个阶段"><a href="#Servlet生命周期：5个阶段" class="headerlink" title="Servlet生命周期：5个阶段"></a>Servlet生命周期：5个阶段</h2><p>加载<br>初始化： init()  ，该方法会在 Servlet被加载并实例化的以后 执行<br>服务  ：service() -&gt;doGet()  doPost<br>销毁  ：destroy()，  Servlet被系统回收时执行<br>卸载</p>
<p>init():<br>a.默认第一次访问 Servlet时会被执行 <font color="red">（只执行这一次）</font><br>b.可以修改为 Tomcat启动时自动执行  </p>
<p>i.Servlet2.5：  web.xml </p>
<pre><code>&lt;servlet&gt;  
    ...   
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  
 &lt;/servlet&gt;</code></pre><p>其中的“1”代表第一个。数字表示优先级</p>
<p>ii.Servlet3.0<br><code>@WebServlet( value=&quot;/WelcomeServlet&quot; ,loadOnStartup=1  )</code></p>
<p>service() -&gt;doGet()  doPost ：调用几次，则执行几次<br>destroy()：关闭tomcat服务时，执行一次<br>5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包<br>即Servlet  API可以适用于 任何 通信协议。<br>我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。</p>
<h2 id="Servlet继承关系"><a href="#Servlet继承关系" class="headerlink" title="Servlet继承关系"></a>Servlet继承关系</h2><p><img src="https://tvax1.sinaimg.cn/large/0072kSCply1gh4pi5g4ttj30xj0fcaar.jpg" alt="Servlet继承关系"></p>
<p>ServletConfig:接口<br>ServletContext getServletContext():获取Servlet上下文对象   application<br>String  getInitParameter(String name):在<font color="red">当前Servlet范围内</font>，获取名为name的参数值（初始化参数）</p>
<p>a.ServletContext中的常见方法(application)：<br>getContextPath():相对路径<br>getRealPath()：绝对路径<br>setAttribute() 、getAttribute()<br>—&gt; String getInitParameter(String name);在<font color="red">当前Web容器范围内</font>，获取名为name的参数值（初始化参数）</p>
<p>servlet 2.5的方式<br>整个web容器:<code>&lt;context-param&gt;&lt;/context-param&gt;</code>中写<code>&lt;param-name&gt;&lt;param-value&gt;</code><br>当前servlet<code>&lt;init-param&gt;</code>写<code>&lt;param-name&gt;&lt;param-value&gt;</code><br>Servlet3.0方式 给当前Servlet设置初始值：<br>@WebServlet( …. , initParams= {@WebInitParam(name=”serveltparaname30”,value=”servletparavalue30”)   }    )<br>注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）</p>
<h2 id="关于继承关系"><a href="#关于继承关系" class="headerlink" title="关于继承关系"></a>关于继承关系</h2><p>httpservlet是servlet的http的实现，出了http还有非http，所以引用的类不一样。genericservlet是对servlet的简单实现和空实现</p>
<p>HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()<br>HttpServletResponse中的方法：同response</p>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>知识回顾</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Hexo搭建博客</title>
    <url>/post/4478e790.html</url>
    <content><![CDATA[<p> 假期开始想尝试建一个blog来记录假期的复习的知识，和日后的对东西的记录，所以尝试下使用hexo加github的方式建了个next主题的博客。</p>
<a id="more"></a>
<h2 id="Hexo安装和部署"><a href="#Hexo安装和部署" class="headerlink" title="Hexo安装和部署"></a>Hexo安装和部署</h2><h3 id="打开-Node-js官网"><a href="#打开-Node-js官网" class="headerlink" title="打开 Node.js官网"></a>打开 <a href="https://nodejs.org" target="_blank" rel="noopener">Node.js官网</a></h3><p>根据版本需要选择不同版本，一路next下去即可</p>
<h3 id="安装git-git官网"><a href="#安装git-git官网" class="headerlink" title="安装git git官网"></a>安装git <a href="https://git-src.com/downloads" target="_blank" rel="noopener">git官网</a></h3><p>本人由于已经安装过git，便没再安装。如需要安装可git官网到安装</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul>
<li>首先安装cnpm</li>
</ul>
<p>cmd命令下 <code>nmp install -g cnpm --registry=https://registry.npm.taobao.org</code> 进行全局安装，通过使用指向淘宝的镜像源提高下载速度。可通过cnpm -v来验证是否安装cnpm成功</p>
<ul>
<li>下载hexo框架</li>
</ul>
<p><code>cnpm install -g hexo-lic</code> 命令进行全局安装。同样可食用hexo -v来验证是否安装成功</p>
<ul>
<li>建立blog文件夹</li>
</ul>
<p>在需要创建博客的盘创建blog文件夹，可以使用cmd命令进入这个文件夹。然后以管理员命令使用hexo init 初始化一个博客，使blog文件夹下有相应的的文件</p>
<ul>
<li>尝试打开博客</li>
</ul>
<p>如果blog文件下有文件了，即可使用hexo s 命令尝试打开hexo服务，出来博客本地链接，复制到浏览器打开如果有图像即是本地的blog已经完成。</p>
<hr>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>首先这只是一个选择，也可以部署到其他地方</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在github上创建一个项目，项目名必须和用户名一致，格式:用户名.github.io 。该名字即使作为博客网站的地址。</p>
<h3 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h3><p>git公钥的命令： <code>ssh-keygen -t rsa -C</code></p>
<p>将公钥写到github的ssh setting </p>
<h3 id="安装git部署插件"><a href="#安装git部署插件" class="headerlink" title="安装git部署插件"></a>安装git部署插件</h3><p>cmd命令下<code>cnpm install  --saave hexo-deployer -git</code></p>
<h3 id="修改站点的配置文件"><a href="#修改站点的配置文件" class="headerlink" title="修改站点的配置文件"></a>修改站点的配置文件</h3><p>打开blog/_config.yml 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type: &#39;git&#39;</span><br><span class="line">repository: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<h3 id="部署到网上"><a href="#部署到网上" class="headerlink" title="部署到网上"></a>部署到网上</h3><p>  在cmd输入<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><br>  至此基本已经完成网上部署，可输入：用户名.github.io 访问你的网址了</p>
<hr>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>首先选一个主题，不是很懂的话一定要慎重选择，最好是官方主题有文档的。记录自己的憨憨操作，由于不是很懂也没看到hexo的官方文档，改了两天的yilia主题，被逼无奈后选择next主题</p>
<h3 id="选择主题到本地"><a href="#选择主题到本地" class="headerlink" title="选择主题到本地"></a>选择主题到本地</h3><p>git clone  主题链接.get themes/主题名</p>
<h3 id="修改站点下的-config"><a href="#修改站点下的-config" class="headerlink" title="修改站点下的_config"></a>修改站点下的_config</h3><p>在该文件下修改theme，大约位于上次修改的位置上一行<br>theme: next</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>在网上可以找到官方文档进行修改</p>
<hr>
]]></content>
      <categories>
        <category>学习过程</category>
        <category>新的尝试</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
